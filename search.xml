<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>한일 육아휴직 제도 비교</title>
      <link href="/japan/child-care-leave-differences-between-korea-japan/"/>
      <url>/japan/child-care-leave-differences-between-korea-japan/</url>
      
        <content type="html"><![CDATA[<p>급여</p><p>기간</p><p>사회적 시선 및 분위기</p><p>성별 비교</p>]]></content>
      
      
      <categories>
          
          <category> japan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 육아휴직 </tag>
            
            <tag> 한일비교 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>파이썬 코드 읽어보기 - http/__init__.py</title>
      <link href="/python/code-reading-http-init/"/>
      <url>/python/code-reading-http-init/</url>
      
        <content type="html"><![CDATA[<h1 id="http-HTTP를-다루기-위한-패키지"><a href="#http-HTTP를-다루기-위한-패키지" class="headerlink" title="http - HTTP를 다루기 위한 패키지"></a>http - HTTP를 다루기 위한 패키지</h1><ul><li>출처 : <a href="https://docs.python.org/3/library/http.html" target="_blank" rel="noopener">https://docs.python.org/3/library/http.html</a></li><li>코드 : <a href="https://github.com/python/cpython/blob/3.7/Lib/http/__init__.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/3.7/Lib/http/__init__.py</a></li></ul><p><strong>파이썬 코드 읽어보기</strong> 두 번째 시리즈는 <code>http</code>입니다. </p><p><code>http</code> 패키지는 다음과 같은 모듈을 포함하고 있습니다.</p><ul><li><code>http.client</code></li><li><code>http.server</code></li><li><code>http.cookies</code> </li><li><code>http.cookiejar</code> </li></ul><p>http 모듈에는 HTTP 상태 코드와 관련 메시지가 정의돼 있습니다.</p><p><code>http/__init__.py</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class HTTPStatus(IntEnum):</span><br><span class="line">    def __new__(cls, value, phrase, description&#x3D;&#39;&#39;):</span><br><span class="line">        obj &#x3D; int.__new__(cls, value)</span><br><span class="line">        obj._value_ &#x3D; value</span><br><span class="line"></span><br><span class="line">        obj.phrase &#x3D; phrase</span><br><span class="line">        obj.description &#x3D; description</span><br><span class="line">        return obj</span><br><span class="line">    ...</span><br><span class="line">    # success</span><br><span class="line">    OK &#x3D; 200, &#39;OK&#39;, &#39;Request fulfilled, document follows&#39;</span><br><span class="line">    CREATED &#x3D; 201, &#39;Created&#39;, &#39;Document created, URL follows&#39;</span><br></pre></td></tr></table></figure><p> <code>__new__()</code> 가 무엇인지 부터 한 번 알아보겠습니다.</p><p><code>builtins.py</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self): # known special case of object.__init__</span><br><span class="line">    &quot;&quot;&quot; Initialize self.  See help(type(self)) for accurate signature. &quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">@staticmethod # known case of __new__</span><br><span class="line">def __new__(cls, *more): # known special case of object.__new__</span><br><span class="line">    &quot;&quot;&quot; Create and return a new object.  See help(type) for accurate signature. &quot;&quot;&quot;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/ko/3.7/reference/datamodel.html#basic-customization" target="_blank" rel="noopener">https://docs.python.org/ko/3.7/reference/datamodel.html#basic-customization</a></p><p><code>__new__()</code> 메소드는 새로운 오브젝트를 생성하고 반환합니다. 그 후 <code>__init__()</code> 메소드가 인스턴스 자체를 초기화 한다. 실행되는 순서는 <code>__new__()</code> -&gt; <code>__init__()</code> 과 같습니다.</p><p><code>__init__.py</code> 는 이정도로 하고 다음 파일 <code>client.py</code> 로 넘어가겠습니다.</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>파이썬 코드 읽어보기 - json/decoder.py, scanner.py</title>
      <link href="/python/code-reading-json-decoder-scanner/"/>
      <url>/python/code-reading-json-decoder-scanner/</url>
      
        <content type="html"><![CDATA[<h1 id="json-JSON-encoder-and-decoder"><a href="#json-JSON-encoder-and-decoder" class="headerlink" title="json - JSON encoder and decoder"></a>json - JSON encoder and decoder</h1><ul><li>출처 : <a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">https://docs.python.org/3/library/json.html</a></li><li>코드 : <a href="https://github.com/python/cpython/blob/3.7/Lib/json/decoder.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/3.7/Lib/json/decoder.py</a></li></ul><p><strong>파이썬 코드 읽어보기</strong> 첫 번째 시리즈는 <code>json</code>입니다. </p><p><code>import json</code></p><p>개발 중 흔하게 만나던 <code>json</code>의 내부는 어떻게 되어 있는지 같이 확인해봅시다. </p><p>저는 <a href="https://github.com/python/cpython/blob/3.7/Lib/json/__init__.py" target="_blank" rel="noopener">cpython repository</a>에서 코드를 확인해봤습니다. 파이썬 코드는 ./Lib/ 디렉토리 아래에서 확인할 수 있습니다.</p><p><code>cpython/Lib/json/</code> 디렉토리안의 내용입니다.</p><ul><li><code>__init__.py</code></li><li><code>decoder.py</code></li><li><code>encoder.py</code></li><li><code>scanner.py</code></li><li><code>tool.py</code></li></ul><p>본 글에서는 <code>decoder.py</code> 와 <code>scanner.py</code> 를 확인해보겠습니다. </p><p>다음과 같은 메소드와 클래스에 대해 자세히 살펴보려합니다.</p><ul><li><code>JSONDecoder</code> - <code>cls</code></li><li><code>JSONDecodeError</code> - <code>cls</code></li><li><code>_decode_uXXXX</code> - <code>method</code></li><li><code>py_scanstring</code> - <code>method</code></li><li><code>JSONObject</code> - <code>method</code></li><li><code>JSONArray</code> - <code>method</code></li></ul><p><code>class JSONDecoder</code> 부터 시작합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class JSONDecoder(object):</span><br><span class="line">    def __init__(self, *, object_hook&#x3D;None, parse_float&#x3D;None,</span><br><span class="line">            parse_int&#x3D;None, parse_constant&#x3D;None, strict&#x3D;True,</span><br><span class="line">            object_pairs_hook&#x3D;None):</span><br><span class="line">        self.object_hook &#x3D; object_hook</span><br><span class="line">        self.parse_float &#x3D; parse_float or float</span><br><span class="line">        self.parse_int &#x3D; parse_int or int</span><br><span class="line">        self.parse_constant &#x3D; parse_constant or _CONSTANTS.__getitem__</span><br><span class="line">        self.strict &#x3D; strict</span><br><span class="line">        self.object_pairs_hook &#x3D; object_pairs_hook</span><br><span class="line">        self.parse_object &#x3D; JSONObject</span><br><span class="line">        self.parse_array &#x3D; JSONArray</span><br><span class="line">        self.parse_string &#x3D; scanstring</span><br><span class="line">        self.memo &#x3D; &#123;&#125;</span><br><span class="line">        self.scan_once &#x3D; scanner.make_scanner(self)</span><br><span class="line"></span><br><span class="line">    def decode(self, s, _w&#x3D;WHITESPACE.match):</span><br><span class="line">        obj, end &#x3D; self.raw_decode(s, idx&#x3D;_w(s, 0).end())</span><br><span class="line">        end &#x3D; _w(s, end).end()</span><br><span class="line">        if end !&#x3D; len(s):</span><br><span class="line">            raise JSONDecodeError(&quot;Extra data&quot;, s, end)</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line">    def raw_decode(self, s, idx&#x3D;0):</span><br><span class="line">        try:</span><br><span class="line">            obj, end &#x3D; self.scan_once(s, idx)</span><br><span class="line">        except StopIteration as err:</span><br><span class="line">            raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None</span><br><span class="line">        return obj, end</span><br></pre></td></tr></table></figure><p>생성자의 각 파라미터에 대한 설명은 생략하겠습니다. </p><p><code>decode()</code> - JSON 문서를 포함하고 있는 스트링 객체를 파이썬 오브젝트로 반환합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from json import JSONDecoder</span><br><span class="line">&gt;&gt;&gt; decoder &#x3D; JSONDecoder()</span><br><span class="line">&gt;&gt;&gt; a &#x3D; decoder.decode(&#39;&#123;&quot;a&quot; : 1&#125;&#39;)</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&#123;&#39;a&#39;: 1&#125;</span><br><span class="line">&gt;&gt;&gt; type(a)</span><br><span class="line">&lt;class &#39;dict&#39;&gt;</span><br></pre></td></tr></table></figure><p><code>raw_decode(self, s, idx=0)</code> - JSON 문서를 디코딩해서 파이썬 객체와 파라미터 <code>s</code>가 끝나는 지점의 인덱스를 <code>tuple</code>의  형태로 반환합니다. </p><p><code>return (object, len(s))</code> 대략 이런 느낌입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; decoder.raw_decode(&#39;&#123;&quot;a&quot;: 123&#125;&#39;)</span><br><span class="line">(&#123;&#39;a&#39;: 123&#125;, 10)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def raw_decode(self, s, idx&#x3D;0):</span><br><span class="line">    try:</span><br><span class="line">        obj, end &#x3D; self.scan_once(s, idx)</span><br><span class="line">    except StopIteration as err:</span><br><span class="line">        raise JSONDecodeError(&quot;Expecting value&quot;, s, err.value) from None</span><br><span class="line">    return obj, end</span><br></pre></td></tr></table></figure><p>어떤 경우에 <code>StopIteration</code> 이 발생하는지 확인해보겠습니다. <code>self.scan_once(s, idx)</code> 메소드는 생성자에서 <code>scanner</code>로 부터 주입받은 것임을 알 수 있습니다. <code>self.scan_once = scanner.make_scanner(self)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># scanner.py</span><br><span class="line"></span><br><span class="line">make_scanner &#x3D; c_make_scanner or py_make_scanner</span><br></pre></td></tr></table></figure><p><code>c</code> 는 제가 잘 몰라서 <code>py_make_scanner</code> 중심으로 어떤 일들이 일어나고 있는지 보겠습니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># scanner.py</span><br><span class="line"></span><br><span class="line">def py_make_scanner(context):</span><br><span class="line">    parse_object &#x3D; context.parse_object</span><br><span class="line">    parse_array &#x3D; context.parse_array</span><br><span class="line">    parse_string &#x3D; context.parse_string</span><br><span class="line">    match_number &#x3D; NUMBER_RE.match</span><br><span class="line">    strict &#x3D; context.strict</span><br><span class="line">    parse_float &#x3D; context.parse_float</span><br><span class="line">    parse_int &#x3D; context.parse_int</span><br><span class="line">    parse_constant &#x3D; context.parse_constant</span><br><span class="line">    object_hook &#x3D; context.object_hook</span><br><span class="line">    object_pairs_hook &#x3D; context.object_pairs_hook</span><br><span class="line">    memo &#x3D; context.memo</span><br><span class="line"></span><br><span class="line">    def _scan_once(string, idx):</span><br><span class="line">        try:</span><br><span class="line">            nextchar &#x3D; string[idx]</span><br><span class="line">        except IndexError:</span><br><span class="line">            raise StopIteration(idx)</span><br><span class="line"></span><br><span class="line">        if nextchar &#x3D;&#x3D; &#39;&quot;&#39;:</span><br><span class="line">            return parse_string(string, idx + 1, strict)</span><br><span class="line">        elif nextchar &#x3D;&#x3D; &#39;&#123;&#39;:</span><br><span class="line">            return parse_object((string, idx + 1), strict,</span><br><span class="line">                _scan_once, object_hook, object_pairs_hook, memo)</span><br><span class="line">        elif nextchar &#x3D;&#x3D; &#39;[&#39;:</span><br><span class="line">            return parse_array((string, idx + 1), _scan_once)</span><br><span class="line">        elif nextchar &#x3D;&#x3D; &#39;n&#39; and string[idx:idx + 4] &#x3D;&#x3D; &#39;null&#39;:</span><br><span class="line">            return None, idx + 4</span><br><span class="line">        elif nextchar &#x3D;&#x3D; &#39;t&#39; and string[idx:idx + 4] &#x3D;&#x3D; &#39;true&#39;:</span><br><span class="line">            return True, idx + 4</span><br><span class="line">        elif nextchar &#x3D;&#x3D; &#39;f&#39; and string[idx:idx + 5] &#x3D;&#x3D; &#39;false&#39;:</span><br><span class="line">            return False, idx + 5</span><br><span class="line"></span><br><span class="line">        m &#x3D; match_number(string, idx)</span><br><span class="line">        if m is not None:</span><br><span class="line">            integer, frac, exp &#x3D; m.groups()</span><br><span class="line">            if frac or exp:</span><br><span class="line">                res &#x3D; parse_float(integer + (frac or &#39;&#39;) + (exp or &#39;&#39;))</span><br><span class="line">            else:</span><br><span class="line">                res &#x3D; parse_int(integer)</span><br><span class="line">            return res, m.end()</span><br><span class="line">        elif nextchar &#x3D;&#x3D; &#39;N&#39; and string[idx:idx + 3] &#x3D;&#x3D; &#39;NaN&#39;:</span><br><span class="line">            return parse_constant(&#39;NaN&#39;), idx + 3</span><br><span class="line">        elif nextchar &#x3D;&#x3D; &#39;I&#39; and string[idx:idx + 8] &#x3D;&#x3D; &#39;Infinity&#39;:</span><br><span class="line">            return parse_constant(&#39;Infinity&#39;), idx + 8</span><br><span class="line">        elif nextchar &#x3D;&#x3D; &#39;-&#39; and string[idx:idx + 9] &#x3D;&#x3D; &#39;-Infinity&#39;:</span><br><span class="line">            return parse_constant(&#39;-Infinity&#39;), idx + 9</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration(idx)</span><br><span class="line"></span><br><span class="line">    def scan_once(string, idx):</span><br><span class="line">        try:</span><br><span class="line">            return _scan_once(string, idx)</span><br><span class="line">        finally:</span><br><span class="line">            memo.clear()</span><br><span class="line"></span><br><span class="line">    return scan_once</span><br></pre></td></tr></table></figure><p><code>py_make_scanner.scan_once()</code> 를 실행하면 내부에 정의된 메소드 <code>scan_once()</code> 가 <code>_scan_once()</code> 프라이빗 메소드를 부른 후 <code>finally</code> 구문을 통해 <code>memo.clear()</code>를 실행합니다.</p><p><code>memo</code> 변수는 <code>memo = context.memo</code> 를 통해 생성된 변수입니다. 그리고 <code>context</code>는  <code>JSONDecoder</code> 클래스의 인스턴스입니다. 따라서 <code>context.memo</code> 는 <code>dict</code> 타입의 변수 입니다. </p><p>이상으로 <code>decoder.py</code> 와 <code>scanner.py</code> 를 간략하게 살펴 보았습니다.</p><p>다음으로는 <code>json/tool.py</code> 의 사용법과 코드를 보도록 하겠습니다. </p><p>감사합니다.</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>파이썬 코드 읽어보기 - json/encoder.py</title>
      <link href="/python/code-reading-json-encoder/"/>
      <url>/python/code-reading-json-encoder/</url>
      
        <content type="html"><![CDATA[<h1 id="json-JSON-encoder-and-decoder"><a href="#json-JSON-encoder-and-decoder" class="headerlink" title="json - JSON encoder and decoder"></a>json - JSON encoder and decoder</h1><ul><li>출처 : <a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">https://docs.python.org/3/library/json.html</a></li><li>코드 : <a href="https://github.com/python/cpython/blob/3.7/Lib/json/encoder.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/3.7/Lib/json/encoder.py</a></li></ul><p><strong>파이썬 코드 읽어보기</strong> 첫 번째 시리즈는 <code>json</code>입니다. </p><p><code>import json</code></p><p>개발 중 흔하게 만나던 <code>json</code>의 내부는 어떻게 되어 있는지 같이 확인해봅시다. </p><p>저는 <a href="https://github.com/python/cpython/blob/3.7/Lib/json/__init__.py" target="_blank" rel="noopener">cpython repository</a>에서 코드를 확인해봤습니다. 파이썬 코드는 ./Lib/ 디렉토리 아래에서 확인할 수 있습니다.</p><p><code>cpython/Lib/json/</code> 디렉토리안의 내용입니다.</p><ul><li><code>__init__.py</code></li><li><code>decoder.py</code></li><li><code>encoder.py</code></li><li><code>scanner.py</code></li><li><code>tool.py</code></li></ul><p>본 글에서는 <code>encoder.py</code>를 확인해보겠습니다. 총 442줄로 구성된 파일로 생각보다 그렇게 길진 않습니다.</p><p>Pycharm을 통해 Structure를 보면 </p><p><img src="/images/json-encoder/json_encoder_structure_01.png" alt="encoder-structure"></p><p><code>V</code>는 변수, <code>f</code> 메소드, <code>C</code> 클래스를 나타냅니다.</p><p><code>encoder.py</code> 의 변수<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ESCAPE &#x3D; re.compile(r&#39;[\x00-\x1f\\&quot;\b\f\n\r\t]&#39;)</span><br><span class="line">ESCAPE_ASCII &#x3D; re.compile(r&#39;([\\&quot;]|[^\ -~])&#39;)</span><br><span class="line">HAS_UTF8 &#x3D; re.compile(b&#39;[\x80-\xff]&#39;)</span><br><span class="line">ESCAPE_DCT &#x3D; &#123;</span><br><span class="line">    &#39;\\&#39;: &#39;\\\\&#39;,</span><br><span class="line">    &#39;&quot;&#39;: &#39;\\&quot;&#39;,</span><br><span class="line">    &#39;\b&#39;: &#39;\\b&#39;,</span><br><span class="line">    &#39;\f&#39;: &#39;\\f&#39;,</span><br><span class="line">    &#39;\n&#39;: &#39;\\n&#39;,</span><br><span class="line">    &#39;\r&#39;: &#39;\\r&#39;,</span><br><span class="line">    &#39;\t&#39;: &#39;\\t&#39;,</span><br><span class="line">&#125;</span><br><span class="line">for i in range(0x20):</span><br><span class="line">    ESCAPE_DCT.setdefault(chr(i), &#39;\\u&#123;0:04x&#125;&#39;.format(i))</span><br><span class="line">    #ESCAPE_DCT.setdefault(chr(i), &#39;\\u%04x&#39; % (i,))</span><br><span class="line"></span><br><span class="line">INFINITY &#x3D; float(&#39;inf&#39;)</span><br></pre></td></tr></table></figure></p><p><code>ESCAPE</code>, <code>ESCAPE_ASCII</code>, <code>HAS_UTF8</code> 세 변수는 <code>re.compile()</code> 메소드의 반환 값으로 <code>regular expression object</code> 입니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(ESCAPE)</span><br><span class="line">&lt;class &#39;_sre.SRE_Pattern&#39;&gt;</span><br></pre></td></tr></table></figure></p><p><code>ESCAPE_DCT</code>는 딕셔너리 타입의 변수로 0~31까지의 정수를 기반으로 만들어졌으며, 실제로 아래 표의 데이터를 가지고 있습니다. </p><table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody><tr><td><code>chr(index)</code></td><td><code>\\u{0:04x}&#39;.format(i)</code></td></tr><tr><td>이하 실제 값</td></tr><tr><td>‘\x00’</td><td>‘\u0000’</td></tr><tr><td>‘\x01’</td><td>‘\u0001’</td></tr><tr><td>‘\x02’</td><td>‘\u0002’</td></tr><tr><td>‘\x03’</td><td>‘\u0003’</td></tr><tr><td>‘\x04’</td><td>‘\u0004’</td></tr><tr><td>‘\x05’</td><td>‘\u0005’</td></tr><tr><td>‘\x06’</td><td>‘\u0006’</td></tr><tr><td>‘\x07’</td><td>‘\u0007’</td></tr><tr><td>‘\x08’</td><td>‘\u0008’</td></tr><tr><td>‘\t’</td><td>‘\t’</td></tr><tr><td>‘\n’</td><td>‘\n’</td></tr><tr><td>‘\x0b’</td><td>‘\u000b’</td></tr><tr><td>‘\x0c’</td><td>‘\u000c’</td></tr><tr><td>‘\r’</td><td>‘\r’</td></tr><tr><td>‘\x0e’</td><td>‘\u000e’</td></tr><tr><td>‘\x0f’</td><td>‘\u000f’</td></tr><tr><td>‘\x10’</td><td>‘\u0010’</td></tr><tr><td>‘\x11’</td><td>‘\u0011’</td></tr><tr><td>‘\x12’</td><td>‘\u0012’</td></tr><tr><td>‘\x13’</td><td>‘\u0013’</td></tr><tr><td>‘\x14’</td><td>‘\u0014’</td></tr><tr><td>‘\x15’</td><td>‘\u0015’</td></tr><tr><td>‘\x16’</td><td>‘\u0016’</td></tr><tr><td>‘\x17’</td><td>‘\u0017’</td></tr><tr><td>‘\x18’</td><td>‘\u0018’</td></tr><tr><td>‘\x19’</td><td>‘\u0019’</td></tr><tr><td>‘\x1a’</td><td>‘\u001a’</td></tr><tr><td>‘\x1b’</td><td>‘\u001b’</td></tr><tr><td>‘\x1c’</td><td>‘\u001c’</td></tr><tr><td>‘\x1d’</td><td>‘\u001e’</td></tr><tr><td>‘\x1e’</td><td>‘\u001d’</td></tr><tr><td>‘\x1f’</td><td>‘\u001f’</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ESCAPE_DCT &#x3D; &#123;</span><br><span class="line">    &#39;\\&#39;: &#39;\\\\&#39;,</span><br><span class="line">    &#39;&quot;&#39;: &#39;\\&quot;&#39;,</span><br><span class="line">    &#39;\b&#39;: &#39;\\b&#39;,</span><br><span class="line">    &#39;\f&#39;: &#39;\\f&#39;,</span><br><span class="line">    &#39;\n&#39;: &#39;\\n&#39;,</span><br><span class="line">    &#39;\r&#39;: &#39;\\r&#39;,</span><br><span class="line">    &#39;\t&#39;: &#39;\\t&#39;,</span><br><span class="line">&#125;</span><br><span class="line">for i in range(0x20):</span><br><span class="line">    ESCAPE_DCT.setdefault(chr(i), &#39;\\u&#123;0:04x&#125;&#39;.format(i))</span><br><span class="line">    #ESCAPE_DCT.setdefault(chr(i), &#39;\\u%04x&#39; % (i,))</span><br></pre></td></tr></table></figure><p><code>setdefault()</code>를 사용하여 키 밸류 맵핑을 했기때문에 <code>ESCAPE_DCT</code> 변수 선언 시 입력된 <code>\n</code>, <code>\r</code>, <code>\t</code> 등의 키는 값의 변화없이 첫 변수 선언 당시의 값을 그대로 유지하고 있습니다.</p><p><code>chr(i)</code> 파이썬 빌트인 메소드로 입력된 정수 파라미터를 유니코드 스트링 형태로 반환합니다. 또 다른 빌트인 메소드 <code>ord()</code>의 반대이기도 합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chr(65)</span><br><span class="line">&#39;A&#39;</span><br><span class="line">&gt;&gt;&gt; ord(&#39;A&#39;)</span><br><span class="line">65</span><br></pre></td></tr></table></figure></p><p>코드 해석과는 별개로 왜 주석 처리된 코드를 지우지 않고 유지하고 있는지 궁금하네요.</p><p><code>INFINITY</code> 변수는 float(‘inf’) 를 할당받고 있습니다. 타입은 당연히 <code>float</code> 이네요.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(float(&#39;inf&#39;))</span><br><span class="line">&lt;class &#39;float&#39;&gt;</span><br></pre></td></tr></table></figure></p><p>다음은 메소드를 보겠습니다. </p><p>일단 아래 첫 번째 4줄의 코드는 <code>_json</code> 모듈로 부터 <code>encode_basestring</code> 메소드를 임포트 하고 있습니다. 찾을 수 없을 경우 <code>None</code>을 할당합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    from _json import encode_basestring as c_encode_basestring</span><br><span class="line">except ImportError:</span><br><span class="line">    c_encode_basestring &#x3D; None</span><br></pre></td></tr></table></figure><p>일단 <code>_json</code> 이 녀석부터 다시 짚고 넘어가고 싶네요.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; json</span><br><span class="line">&lt;module &#39;json&#39; from &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;json&#x2F;__init__.py&#39;&gt;</span><br><span class="line"></span><br><span class="line"># From mac OS</span><br><span class="line">&gt;&gt;&gt; import _json</span><br><span class="line">&gt;&gt;&gt; _json</span><br><span class="line">&lt;module &#39;_json&#39; from &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;lib-dynload&#x2F;_json.cpython-36m-darwin.so&#39;&gt;</span><br><span class="line"></span><br><span class="line"># From linux </span><br><span class="line">&gt;&gt;&gt; _json</span><br><span class="line">&lt;module &#39;_json&#39; from &#39;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.7&#x2F;lib-dynload&#x2F;_json.cpython-37m-x86_64-linux-gnu.so&#39;&gt;</span><br></pre></td></tr></table></figure><br><code>json</code>의 경우 지금 보고 있는 파일이 있는 모듈과 동일한 위치에 있습니다. </p><p><code>_json</code> 은 <code>/lib-dynload/_json.&lt;BUILD_NAME&gt;.so</code> 으로 보이는군요. cpython 빌드 후 생성되는 파일로 보이네요. 파일 경로 <code>cpython/Modules/_json.c</code> <a href="https://github.com/python/cpython/blob/master/Modules/_json.c" target="_blank" rel="noopener"> link</a></p><p><code>.so</code> 확장자는 이번 기회에 처음보게 됐는데요, <code>shared object</code>라고 하네요. </p><p>참고용 -&gt; <a href="https://stackoverflow.com/questions/9809213/what-are-a-and-so-files" target="_blank" rel="noopener">stack overflow 답변 링크</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def py_encode_basestring(s):</span><br><span class="line">    &quot;&quot;&quot;Return a JSON representation of a Python string</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def replace(match):</span><br><span class="line">        return ESCAPE_DCT[match.group(0)]</span><br><span class="line">    return &#39;&quot;&#39; + ESCAPE.sub(replace, s) + &#39;&quot;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">encode_basestring &#x3D; (c_encode_basestring or py_encode_basestring)</span><br></pre></td></tr></table></figure><p>파이썬 스트링의 JSON 표현을 반환합니다. 실제 메소드의 반환값은 아래 보이는 것과 같습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import json.encoder</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; json.encoder.py_encode_basestring(&quot;abcdef&quot;)</span><br><span class="line">&#39;&quot;abcdef&quot;&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; json.encoder.py_encode_basestring(&quot;&#123;&#39;key&#39;: &#39;value&#39;&#125;&quot;)</span><br><span class="line">&#39;&quot;&#123;\&#39;key\&#39;: \&#39;value\&#39;&#125;&quot;&#39;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encode_basestring &#x3D; (c_encode_basestring or py_encode_basestring)</span><br></pre></td></tr></table></figure><p>cpython의 c_encode_basestring을 임포트할 수 있다면 c_encode_basestring 메소드를 사용합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def py_encode_basestring_ascii(s):</span><br><span class="line">    &quot;&quot;&quot;Return an ASCII-only JSON representation of a Python string</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def replace(match):</span><br><span class="line">        s &#x3D; match.group(0)</span><br><span class="line">        try:</span><br><span class="line">            return ESCAPE_DCT[s]</span><br><span class="line">        except KeyError:</span><br><span class="line">            n &#x3D; ord(s)</span><br><span class="line">            if n &lt; 0x10000:</span><br><span class="line">                return &#39;\\u&#123;0:04x&#125;&#39;.format(n)</span><br><span class="line">                #return &#39;\\u%04x&#39; % (n,)</span><br><span class="line">            else:</span><br><span class="line">                # surrogate pair</span><br><span class="line">                n -&#x3D; 0x10000</span><br><span class="line">                s1 &#x3D; 0xd800 | ((n &gt;&gt; 10) &amp; 0x3ff)</span><br><span class="line">                s2 &#x3D; 0xdc00 | (n &amp; 0x3ff)</span><br><span class="line">                return &#39;\\u&#123;0:04x&#125;\\u&#123;1:04x&#125;&#39;.format(s1, s2)</span><br><span class="line">    return &#39;&quot;&#39; + ESCAPE_ASCII.sub(replace, s) + &#39;&quot;&#39;</span><br></pre></td></tr></table></figure><p>파이썬 스트링의 JSON 표현을 반환합니다. 다만 ASCII 코드만 반환합니다.</p><p><code>py_encode_basestring_ascii()</code> 안에 있는 <code>replace()</code> 메소드를 보겠습니다. </p><p>처음에 소개한 <code>ESCAPE_DCT</code>에서 <code>match.group(0)</code>을 키로 조회합니다. <code>ESCAPE_DCT</code> 객체는 0~31까지의 수로 만들어진 <code>\x00</code> ~ <code>\x1f</code> 를 키로 가지고 있습니다. 그렇기에 이외의 키로 조회하면 <code>KeyError</code>를 일으켜 <code>except</code> 구문으로 넘어가게됩니다. <code>ord(s)</code>를 통해 <code>n</code>은 0이상의 정수를 할당받습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if n &lt; 0x10000:</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0x10000</span><br><span class="line">65536</span><br><span class="line">&gt;&gt;&gt; &#39;\\u&#123;0:04x&#125;&#39;.format(65535)</span><br><span class="line">&#39;\\uffff&#39;   # OK</span><br><span class="line">&gt;&gt;&gt; &#39;\\u&#123;0:04x&#125;&#39;.format(0)</span><br><span class="line">&#39;\\u0000&#39;   # OK</span><br></pre></td></tr></table></figure><p><code>u0000~uffff</code>에 해당하는 문자열의 경우 위에 보이는 것과 같은 형태로 반환합니다.  </p><p>코드를 읽다보니 <code>u0000~uffff</code>라는 범위는 어떤 기준으로 만들어진 것일까 라는 의문이 들었습니다.</p><ul><li><a href="https://en.wikipedia.org/wiki/Plane_(Unicode" target="_blank" rel="noopener">Plane</a>)</li><li><a href="https://en.wikipedia.org/wiki/Plane_(Unicode" target="_blank" rel="noopener">BMP</a>#Basic_Multilingual_Plane)</li></ul><p>위 링크를 참조하여 간단히 설명하면, <code>Plane</code>은 65,536개의 연속된 코드포인트라고 할 수 있습니다. 총 17개의 <code>plane</code>이 존재하며, <code>u0000~uffff</code>은 십진수로 변환시 0~65,535이기에 첫 번째 <code>Plane</code>이라고 할 수 있습니다. </p><p><code>BMP</code>는 <code>Basic Multilingual Plane</code>의 약자이며, 첫 번째 <code>plane</code>을 의미합니다. 첫 번째 <code>plane</code>인 <code>BMP</code>는 현대 언어의 거의 모든 문자와 기호를 포함하고 있다고 합니다. CJK의 문자와 기호가 <code>BMP</code>의 많은 부분을 차지하고 있다고 합니다. </p><p>다음으로 <code>else</code> 절을 보겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">else:</span><br><span class="line">    # surrogate pair</span><br><span class="line">    n -&#x3D; 0x10000</span><br><span class="line">    s1 &#x3D; 0xd800 | ((n &gt;&gt; 10) &amp; 0x3ff)</span><br><span class="line">    s2 &#x3D; 0xdc00 | (n &amp; 0x3ff)</span><br><span class="line">    return &#39;\\u&#123;0:04x&#125;\\u&#123;1:04x&#125;&#39;.format(s1, s2)</span><br></pre></td></tr></table></figure><p><code>surrogate pair</code>가 무엇인지 부터 알아야겠네요. 아래 두 글을 참조하여 알아보겠습니다. </p><ul><li><a href="https://stackoverflow.com/questions/5903008/what-is-a-surrogate-pair-in-java" target="_blank" rel="noopener">What is a “surrogate pair” in Java? - stackoverflow</a></li></ul><ul><li><a href="https://en.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16 - Wikipedia</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from stackoverflow </span><br><span class="line"></span><br><span class="line">The term &quot;surrogate pair&quot; refers to a means of encoding Unicode characters with high code-points in the UTF-16 encoding scheme.</span><br><span class="line"></span><br><span class="line">In the Unicode character encoding, characters are mapped to values between 0x0 and 0x10FFFF.</span><br><span class="line"></span><br><span class="line">Internally, Java uses the UTF-16 encoding scheme to store strings of Unicode text. In UTF-16, 16-bit (two-byte) code units are used. Since 16 bits can only contain the range of characters from 0x0 to 0xFFFF, some additional complexity is used to store values above this range (0x10000 to 0x10FFFF). This is done using pairs of code units known as surrogates.</span><br><span class="line"></span><br><span class="line">The surrogate code units are in two ranges known as &quot;high surrogates&quot; and &quot;low surrogates&quot;, depending on whether they are allowed at the start or end of the two-code-unit sequence.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from Wikipedia</span><br><span class="line"></span><br><span class="line">Code points from the other planes (called Supplementary Planes) are encoded as two 16-bit code units called a surrogate pair, by the following scheme:</span><br><span class="line"></span><br><span class="line">Examples</span><br><span class="line">To encode U+10437 (𐐷) to UTF-16:</span><br><span class="line"></span><br><span class="line">- Subtract 0x10000 from the code point, leaving 0x0437.</span><br><span class="line">- For the high surrogate, shift right by 10 (divide by 0x400), then add 0xD800, resulting in 0x0001 + 0xD800 &#x3D; 0xD801.</span><br><span class="line">- For the low surrogate, take the low 10 bits (remainder of dividing by 0x400), then add 0xDC00, resulting in 0x0037 + 0xDC00 &#x3D; 0xDC37.</span><br><span class="line"></span><br><span class="line">To decode U+10437 (𐐷) from UTF-16:</span><br><span class="line">- Take the high surrogate (0xD801) and subtract 0xD800, then multiply by 0x400, resulting in 0x0001 × 0x400 &#x3D; 0x0400.</span><br><span class="line">- Take the low surrogate (0xDC37) and subtract 0xDC00, resulting in 0x37.</span><br><span class="line">- Add these two results together (0x0437), and finally add 0x10000 to get the final decoded UTF-32 code point, 0x10437.</span><br></pre></td></tr></table></figure><p>네, 잘 알아보았습니다. 역시 <code>Wikipedia</code>의 Example을 보니 좀 이해가 가네요.</p><p>다음으로 <code>JSONEncoder</code> 클래스를 보겠습니다.</p><p>위 클래스의 메소드를 보겠습니다. 참고로 가독성을 위해 메소드의 파라미터는 생략했습니다.</p><ul><li><code>__init__()</code></li><li><code>default()</code></li><li><code>encode()</code></li><li><code>iterencode()</code></li><li><code>_make_iterencode()</code></li></ul><p>생성자, 퍼블릭 메소드 셋, 프라이빗 메소드 하나를 가지고 있습니다.</p><p><code>__init__()</code> : 생성자의 경우 특별한 로직 없이 입력받은 파라미터를 인스턴스 변수로 지정합니다. 다만 몇몇 변수의 경우 입력되지 않은 경우 기존에 있는 변수 및 메소드를 사용합니다. </p><p><code>default()</code> : 어떤 값이 입력되어도 <code>TypeError</code>를 일으키도록 돼있습니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def default(self, o):</span><br><span class="line">    raise TypeError(f&#39;Object of type &#123;o.__class__.__name__&#125; &#39;</span><br><span class="line">                    f&#39;is not JSON serializable&#39;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Specializing JSON object encoding::</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; import json</span><br><span class="line">    &gt;&gt;&gt; def encode_complex(obj):</span><br><span class="line">    ...     if isinstance(obj, complex):</span><br><span class="line">    ...         return [obj.real, obj.imag]</span><br><span class="line">    ...     raise TypeError(f&#39;Object of type &#123;obj.__class__.__name__&#125; &#39;</span><br><span class="line">    ...                     f&#39;is not JSON serializable&#39;)</span><br><span class="line">    ...</span><br><span class="line">    &gt;&gt;&gt; json.dumps(2 + 1j, default&#x3D;encode_complex)</span><br><span class="line">    &#39;[2.0, 1.0]&#39;</span><br><span class="line">    &gt;&gt;&gt; json.JSONEncoder(default&#x3D;encode_complex).encode(2 + 1j)</span><br><span class="line">    &#39;[2.0, 1.0]&#39;</span><br><span class="line">    &gt;&gt;&gt; &#39;&#39;.join(json.JSONEncoder(default&#x3D;encode_complex).iterencode(2 + 1j))</span><br><span class="line">    &#39;[2.0, 1.0]&#39;</span><br></pre></td></tr></table></figure><p>위와 같이 <code>JSONEncoder</code>를 통해 인스턴스를 만들때 <code>default</code> 파라미터에 자신이 만든 <code>encode</code>용 메소드를 지정할 수 있습니다. </p><p><code>encode()</code> : 파이썬 자료구조의 오브젝트를 JSON형태의 스트링으로 반환합니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from json.encoder import JSONEncoder</span><br><span class="line">&gt;&gt;&gt; JSONEncoder().encode(&#123;&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]&#125;)</span><br><span class="line">&#39;&#123;&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]&#125;&#39;</span><br></pre></td></tr></table></figure></p><p>조금 더 자세히 해당 메소드를 보겠습니다. </p><p>첫 번째로 입력받은 파라미터가 <code>str</code> 인 경우 </p><p><code>isinstance()</code>로 파라미터의 타입을 알아냅니다. <code>str</code>이 맞다면 인스턴스 변수 중 ensure_ascii의 값에 따라 <code>encode_basestring_ascii()</code> 또는 <code>encode_basestring()</code> 의 결과값을 반환하며 메소드가 끝이 납니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; encoder.encode(&#39;a&#39;)</span><br><span class="line">&#39;&quot;a&quot;&#39;</span><br></pre></td></tr></table></figure><p>파라미터가 <code>str</code> 가 아니라면 인스턴스 메소드 <code>iterencode()</code>의 반환값을 <code>chunks</code>에 할당하고, <code>chunks</code>가 <code>list</code> 또는 <code>tuple</code>이 아닌경우 <code>chunks</code> 를 <code>list</code>로 변환시켜 <code>return &#39;&#39;.join(chunks)</code>으로 본 메소드는 마무리 됩니다. </p><p><code>iterencode(self, o, _one_shot=False)</code> : 입력된 오브젝트를 인코드한 후 <code>yield</code> 합니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">For example::</span><br><span class="line"></span><br><span class="line">for chunk in JSONEncoder().iterencode(bigobject):</span><br><span class="line">    mysocket.write(chunk)</span><br></pre></td></tr></table></figure><p>코드를 확인해 보니<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (_one_shot and c_make_encoder is not None</span><br><span class="line">        and self.indent is None):</span><br><span class="line">    _iterencode &#x3D; c_make_encoder(</span><br><span class="line">        markers, self.default, _encoder, self.indent,</span><br><span class="line">        self.key_separator, self.item_separator, self.sort_keys,</span><br><span class="line">        self.skipkeys, self.allow_nan)</span><br><span class="line">else:</span><br><span class="line">    _iterencode &#x3D; _make_iterencode(</span><br><span class="line">        markers, self.default, _encoder, self.indent, floatstr,</span><br><span class="line">        self.key_separator, self.item_separator, self.sort_keys,</span><br><span class="line">        self.skipkeys, _one_shot)</span><br><span class="line">return _iterencode(o, 0)</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure></p><p><code>iterencode()</code>는 파라미터를 입력받아 <code>_make_iterencode()</code> 메소드를 부르고 있습니다.</p><p><code>encoder.py</code> 의 인코딩하는 주요 로직은 <code>_make_iterencode()</code>에 있었습니다. 프라이빗 메소드라서 안보고 넘어가려고 했는데 볼 수 밖에 없겠군요.</p><p><code>_make_iterencode()</code> 는 내부에 세개의 프라이빗 메소드를 가지고 있습니다. </p><p>각각의 역할은 다음과 같습니다. </p><ul><li><code>_iterencode()</code> : 로직이 처음으로 시작되는 메소드입니다. 입력된 오브젝트의 타입에 따라 적절한 메소드를 실행시킵니다.</li><li><code>_iterencode_list()</code> : 오브젝트가 리스트 혹은 튜플 타입</li><li><code>_iterencode_dict()</code> : 오브젝트가 딕셔너리 타입</li></ul><p><code>def _iterencode(o, _current_indent_level):</code> 를 좀 더 자세히 보겠습니다. </p><p>입력된 오브젝트의 타입에 따라 적절한 메소드를 실행합니다. [<code>str</code>, <code>None</code>, <code>Bool</code>, <code>int</code>, <code>float</code>, <code>list</code>, <code>tuple</code>, <code>dict</code>] 이외의 타입은 <code>else</code> 절로 분기처리됩니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def _iterencode(o, _current_indent_level)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">    if markers is not None:</span><br><span class="line">        markerid &#x3D; id(o)</span><br><span class="line">        if markerid in markers:</span><br><span class="line">            raise ValueError(&quot;Circular reference detected&quot;)</span><br><span class="line">        markers[markerid] &#x3D; o</span><br><span class="line">    o &#x3D; _default(o)</span><br><span class="line">    yield from _iterencode(o, _current_indent_level)</span><br><span class="line">    if markers is not None:</span><br><span class="line">        del markers[markerid]</span><br></pre></td></tr></table></figure><p>다음 로직은 <code>markers</code> 의 값에 따라 결정됩니다. <code>markers</code>는 <code>iterencode()</code> 메소드 안에서 check_circular의 값에 따라 결정됩니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def iterencode(self, o, _one_shot&#x3D;False):</span><br><span class="line">    if self.check_circular:</span><br><span class="line">        markers &#x3D; &#123;&#125;</span><br><span class="line">    else:</span><br><span class="line">        markers &#x3D; None</span><br></pre></td></tr></table></figure><p><code>check_circular</code>의 역할은 다음과 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If check_circular is true, then lists, dicts, and custom encoded</span><br><span class="line">objects will be checked for circular references during encoding to</span><br><span class="line">prevent an infinite recursion (which would cause an OverflowError).</span><br><span class="line">Otherwise, no such check takes place.</span><br></pre></td></tr></table></figure><p>인코딩중 일어날 수 있는 <code>infinite recursion(무한 재귀)</code> 를 막기위한 파라미터로 <code>true</code>인 경우 <code>circular references</code> 여부를 검사합니다. </p><p><code>JSONEncoder</code> 생성자의 <code>check_circular=True</code> 와 같은 기본 값을 가지고 있습니다. 특별히 <code>False</code>로 지정하지 않는 한 순환 참조와 관련한 검사가 실행됩니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def _iterencode(o, _current_indent_level)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">    if markers is not None:</span><br><span class="line">        markerid &#x3D; id(o)</span><br><span class="line">        if markerid in markers:</span><br><span class="line">            raise ValueError(&quot;Circular reference detected&quot;)</span><br><span class="line">        markers[markerid] &#x3D; o</span><br><span class="line">    o &#x3D; _default(o)</span><br><span class="line">    yield from _iterencode(o, _current_indent_level)</span><br><span class="line">    if markers is not None:</span><br><span class="line">        del markers[markerid]</span><br></pre></td></tr></table></figure><p>다시 <code>_iterencode()</code> 코드를 보겠습니다. 특별한 변경이 없다면 <code>markers</code>는 빈 딕셔너리를 값으로 가지고 있습니다. 빌트인 메소드 <code>id()</code> 를 통해 입력받은 오브젝트의 식별값을 <code>makers</code>의 <code>key</code>, 오브젝트를 <code>value</code>로 할당합니다. </p><p>다음으로 <code>_default()</code> 메소드로 오브젝트 직렬화 가능한 객체로 변환시킵니다. 만약 직렬화 가능하지 않다면 <code>TypeError</code>를 일으킵니다.</p><p><a href="https://docs.python.org/3/library/json.html#json.JSONEncoder" target="_blank" rel="noopener">json - python3 official document</a>에서 <code>default()</code> 메소드에 관한 설명을 가져왔습니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returns a serializable object for o if possible, otherwise it should call the superclass implementation (to raise TypeError).</span><br></pre></td></tr></table></figure><p>직렬화 된 객체를 다시 본 메소드(<code>_iterencode()</code>)의 첫 번째 파라미터로 넣어 메소드를 실행합니다. <code>yield from</code> 예약 키워드를 통해 본 메소드의 반환 값을 <code>yield</code> 합니다. 그 후 <code>markers</code> 에서 <code>makerid</code> 키를 제거합니다.</p><p>(yield 번역을 어떻게 해야할지 잘 모르겠네요…)</p><p><code>yield from</code> 표현식에 익숙치 않아서 그런지 좀 찾아봤습니다.</p><ul><li><a href="https://docs.python.org/3/whatsnew/3.3.html" target="_blank" rel="noopener">https://docs.python.org/3/whatsnew/3.3.html</a></li><li>New syntax features:</li><li>New <code>yield from</code> expression for <a href="https://docs.python.org/3/whatsnew/3.3.html#pep-380" target="_blank" rel="noopener">generator delegation</a>.</li></ul><p><code>generator delegation</code> 제너레이터 위임이라… 정확한 내용은 문서를 좀 더 읽어보겠습니다. 추가로 기존에 있던 <code>yeild</code> 와 어떤 차이가 있는지도 알아두고 싶네요.</p><p>일단 <code>3.3</code>에 추가된 기능이군요. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PEP 380 adds the &#39;yield from&#39; expression, allowing a generator to delegate part of its operations to another generator. This allows a section of code containing yield to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator.</span><br></pre></td></tr></table></figure><p>해석은 여러분들 각자에게 맡기겠습니다.</p><p>이것으로 <code>json/encoder.py</code> 읽어보기가 끝났습니다. 다음으로는 <code>decoder.py</code> 가 이어집니다.</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>파이썬 코드 읽어보기 - json/__init__.py</title>
      <link href="/python/code-reading-json-init/"/>
      <url>/python/code-reading-json-init/</url>
      
        <content type="html"><![CDATA[<h1 id="json-JSON-encoder-and-decoder"><a href="#json-JSON-encoder-and-decoder" class="headerlink" title="json - JSON encoder and decoder"></a>json - JSON encoder and decoder</h1><ul><li>출처 : <a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">https://docs.python.org/3/library/json.html</a></li><li>코드 : <a href="https://github.com/python/cpython/blob/3.7/Lib/json/__init__.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/3.7/Lib/json/__init__.py</a></li></ul><p><strong>파이썬 코드 읽어보기</strong> 첫 번째 시리즈는 <code>json</code>입니다. </p><p><code>import json</code></p><p>개발 중 흔하게 만나던 <code>json</code>의 내부는 어떻게 되어 있는지 같이 확인해봅시다. </p><p>저는 <a href="https://github.com/python/cpython/blob/3.7/Lib/json/__init__.py" target="_blank" rel="noopener">cpython repository</a>에서 코드를 확인해봤습니다. 파이썬 코드는 ./Lib/ 디렉토리 아래에서 확인할 수 있습니다.</p><p><code>cpython/Lib/json/</code> 디렉토리안의 내용입니다.</p><ul><li><code>__init__.py</code></li><li><code>decoder.py</code></li><li><code>encoder.py</code></li><li><code>scanner.py</code></li><li><code>tool.py</code></li></ul><p>본 글에서는 <code>__init__.py</code>를 확인해보겠습니다.</p><h3 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a><code>__init__.py</code></h3><p>메소드 및 주요 변수 중심으로 천천히 설명하겠습니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def dump(obj, fp, *, skipkeys&#x3D;False, ensure_ascii&#x3D;True, check_circular&#x3D;True,</span><br><span class="line">         allow_nan&#x3D;True, cls&#x3D;None, indent&#x3D;None, separators&#x3D;None,</span><br><span class="line">         default&#x3D;None, sort_keys&#x3D;False, **kw):</span><br><span class="line">    if (not skipkeys and ensure_ascii and</span><br><span class="line">        check_circular and allow_nan and</span><br><span class="line">        cls is None and indent is None and separators is None and</span><br><span class="line">        default is None and not sort_keys and not kw):</span><br><span class="line">        iterable &#x3D; _default_encoder.iterencode(obj)</span><br><span class="line">    else:</span><br><span class="line">        if cls is None:</span><br><span class="line">            cls &#x3D; JSONEncoder</span><br><span class="line">        iterable &#x3D; cls(skipkeys&#x3D;skipkeys, ensure_ascii&#x3D;ensure_ascii,</span><br><span class="line">            check_circular&#x3D;check_circular, allow_nan&#x3D;allow_nan, indent&#x3D;indent,</span><br><span class="line">            separators&#x3D;separators,</span><br><span class="line">            default&#x3D;default, sort_keys&#x3D;sort_keys, **kw).iterencode(obj)</span><br><span class="line">    # could accelerate with writelines in some versions of Python, at</span><br><span class="line">    # a debuggability cost</span><br><span class="line">    for chunk in iterable:</span><br><span class="line">        fp.write(chunk)</span><br></pre></td></tr></table></figure><p><code>dump()</code>는 첫 번째 변수로 받는 <code>obj</code>를 JSON 포맷으로 변환하여 두 번째 변수로 받는 <code>fp</code>(<a href="https://docs.python.org/ko/3/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a>, file-like object 와 동의어, streams라고 불리기도 한다)에 변환된 값을 넣는 메소드입니다. </p><p>파이썬 오브젝트가 어떤 타입으로 변환되는지는 아래의 표를 참조하여 확인할 수 있다.</p><table><thead><tr><th>Python</th><th>JSON</th></tr></thead><tbody><tr><td>dict</td><td>object</td></tr><tr><td>list, tuple</td><td>array</td></tr><tr><td>str</td><td>string</td></tr><tr><td>int, float, int- &amp; float-derived Enums</td><td>number</td></tr><tr><td>True</td><td>true</td></tr><tr><td>False</td><td>false</td></tr><tr><td>None</td><td>null</td></tr></tbody></table><p><code>json</code> 모듈은 생성하는 오브젝트의 타입은 항상 <code>str</code>이기 때문에 <code>fp</code> 오브젝트 역시 <code>str</code> 타입의 인풋이 가능해야만 한다.</p><p>첫 번째 <code>if/else</code>절을 보면 특별히 파라미터를 지정하지 않은 경우 <code>_default_encoder</code>을 사용하여 입력 받은 첫번째 파라미터, 즉 오브젝트를 <code>iterable</code>라는 이름의 iterable 객체로 반환합니다. <code>obj, fp</code> 이외의 파라미터가 입력되면 <code>else</code> 절로 들어가게 됩니다. <code>cls</code>가 특별히 입력되지 않은 경우, <code>JSONEncoder</code>를 사용합니다. </p><p><code>iterable</code> 객체를 for loop을 통해 두 번째 파라미터 <code>fp</code>에 값을 작성합니다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def dumps(obj, *, skipkeys&#x3D;False, ensure_ascii&#x3D;True, check_circular&#x3D;True,</span><br><span class="line">        allow_nan&#x3D;True, cls&#x3D;None, indent&#x3D;None, separators&#x3D;None,</span><br><span class="line">        default&#x3D;None, sort_keys&#x3D;False, **kw):</span><br><span class="line">    # cached encoder</span><br><span class="line">    if (not skipkeys and ensure_ascii and</span><br><span class="line">        check_circular and allow_nan and</span><br><span class="line">        cls is None and indent is None and separators is None and</span><br><span class="line">        default is None and not sort_keys and not kw):</span><br><span class="line">        return _default_encoder.encode(obj)</span><br><span class="line">    if cls is None:</span><br><span class="line">        cls &#x3D; JSONEncoder</span><br><span class="line">    return cls(</span><br><span class="line">        skipkeys&#x3D;skipkeys, ensure_ascii&#x3D;ensure_ascii,</span><br><span class="line">        check_circular&#x3D;check_circular, allow_nan&#x3D;allow_nan, indent&#x3D;indent,</span><br><span class="line">        separators&#x3D;separators, default&#x3D;default, sort_keys&#x3D;sort_keys,</span><br><span class="line">        **kw).encode(obj)</span><br></pre></td></tr></table></figure><p><code>dumps()</code> 와 <code>dump()</code> 의 차이점,<br>| dump()                                 | dumps()   |<br>|—————————————-|——–|<br>| 객체를 반환하지 않는다.                      | 객체를 반환한다.        |</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def detect_encoding(b):</span><br><span class="line">    bstartswith &#x3D; b.startswith</span><br><span class="line">    if bstartswith((codecs.BOM_UTF32_BE, codecs.BOM_UTF32_LE)):</span><br><span class="line">        return &#39;utf-32&#39;</span><br><span class="line">    if bstartswith((codecs.BOM_UTF16_BE, codecs.BOM_UTF16_LE)):</span><br><span class="line">        return &#39;utf-16&#39;</span><br><span class="line">    if bstartswith(codecs.BOM_UTF8):</span><br><span class="line">        return &#39;utf-8-sig&#39;</span><br><span class="line"></span><br><span class="line">    if len(b) &gt;&#x3D; 4:</span><br><span class="line">        if not b[0]:</span><br><span class="line">            # 00 00 -- -- - utf-32-be</span><br><span class="line">            # 00 XX -- -- - utf-16-be</span><br><span class="line">            return &#39;utf-16-be&#39; if b[1] else &#39;utf-32-be&#39;</span><br><span class="line">        if not b[1]:</span><br><span class="line">            # XX 00 00 00 - utf-32-le</span><br><span class="line">            # XX 00 00 XX - utf-16-le</span><br><span class="line">            # XX 00 XX -- - utf-16-le</span><br><span class="line">            return &#39;utf-16-le&#39; if b[2] or b[3] else &#39;utf-32-le&#39;</span><br><span class="line">    elif len(b) &#x3D;&#x3D; 2:</span><br><span class="line">        if not b[0]:</span><br><span class="line">            # 00 XX - utf-16-be</span><br><span class="line">            return &#39;utf-16-be&#39;</span><br><span class="line">        if not b[1]:</span><br><span class="line">            # XX 00 - utf-16-le</span><br><span class="line">            return &#39;utf-16-le&#39;</span><br><span class="line">    # default</span><br><span class="line">    return &#39;utf-8&#39;</span><br></pre></td></tr></table></figure><p><code>detect_encoding()</code> 입력된 파라미터 <code>b</code>(바이트) 의 인코딩을 <code>str</code> 로 반환하는 메소드. <code>codecs.py</code> 안의  <code>BOM_UTF32_BE</code>, <code>BOM_UTF32_LE</code>, <code>BOM_UTF16_BE</code>, <code>BOM_UTF16_LE</code>, <code>BOM_UTF8</code>와 같은 상수를 사용하여 입력된 문자열의 인코딩을 판단합니다. </p><p><code>codecs.py</code> 안의 상수들을 한 번 보겠습니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Byte Order Mark (BOM &#x3D; ZERO WIDTH NO-BREAK SPACE &#x3D; U+FEFF)</span><br><span class="line"># and its possible byte string values</span><br><span class="line"># for UTF8&#x2F;UTF16&#x2F;UTF32 output and little&#x2F;big endian machines</span><br><span class="line"></span><br><span class="line"># UTF-8</span><br><span class="line">BOM_UTF8 &#x3D; b&#39;\xef\xbb\xbf&#39;</span><br><span class="line"></span><br><span class="line"># UTF-16, little endian</span><br><span class="line">BOM_LE &#x3D; BOM_UTF16_LE &#x3D; b&#39;\xff\xfe&#39;</span><br><span class="line"></span><br><span class="line"># UTF-16, big endian</span><br><span class="line">BOM_BE &#x3D; BOM_UTF16_BE &#x3D; b&#39;\xfe\xff&#39;</span><br><span class="line"></span><br><span class="line"># UTF-32, little endian</span><br><span class="line">BOM_UTF32_LE &#x3D; b&#39;\xff\xfe\x00\x00&#39;</span><br><span class="line"></span><br><span class="line"># UTF-32, big endian</span><br><span class="line">BOM_UTF32_BE &#x3D; b&#39;\x00\x00\xfe\xff&#39;</span><br></pre></td></tr></table></figure><p>보기에 앞서 주석 처리된 첫 번째 세 줄을 보면 <a href="https://simple.wikipedia.org/wiki/Byte_order_mark" target="_blank" rel="noopener">BOM(Byte order mark)</a> 이라는 단어를 발견할 수 있습니다. BOM은 해당 텍스트 파일의 인코딩을 명시하며 따라서 식별될 수도 있는 문자열 입니다. 유니코드 문자열 U+FEFF로서 인코딩 됩니다. BOM의 사용은 선택적으로 적용될 수 있으며, 사용하는 경우엔 텍스트 스트림의 첫 지점에 나타나야 합니다. BOM은 <a href="https://simple.wikipedia.org/wiki/Endianness" target="_blank" rel="noopener">endianess</a>, encoding(utf-8, utf-16, etc…) 등의 정보를 가지고 있습니다.</p><p><a href="https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding" target="_blank" rel="noopener">Byte order marks by encoding</a> from wikipedia</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def load(fp, *, cls&#x3D;None, object_hook&#x3D;None, parse_float&#x3D;None,</span><br><span class="line">         parse_int&#x3D;None, parse_constant&#x3D;None, object_pairs_hook&#x3D;None, **kw):</span><br><span class="line">    return loads(fp.read(),</span><br><span class="line">                 cls&#x3D;cls, object_hook&#x3D;object_hook,</span><br><span class="line">                 parse_float&#x3D;parse_float, parse_int&#x3D;parse_int,</span><br><span class="line">                 parse_constant&#x3D;parse_constant, object_pairs_hook&#x3D;object_pairs_hook, **kw)</span><br></pre></td></tr></table></figure><p><code>load()</code>는 <code>dump()</code>와 반대의 기능입니다. fp(file-like object)를 파이썬 오브젝트로 deserialize(역직렬화)해주는 기능입니다. <code>load()</code> 메소드 자체는 별다른 로직을 가지고 있지 않습니다. 아래에 있는 <code>loads()</code>를 호출하고 있습니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">def loads(s, *, encoding&#x3D;None, cls&#x3D;None, object_hook&#x3D;None, parse_float&#x3D;None,</span><br><span class="line">        parse_int&#x3D;None, parse_constant&#x3D;None, object_pairs_hook&#x3D;None, **kw):</span><br><span class="line">    if isinstance(s, str):</span><br><span class="line">        if s.startswith(&#39;\ufeff&#39;):</span><br><span class="line">            raise JSONDecodeError(&quot;Unexpected UTF-8 BOM (decode using utf-8-sig)&quot;,</span><br><span class="line">                                  s, 0)</span><br><span class="line">    else:</span><br><span class="line">        if not isinstance(s, (bytes, bytearray)):</span><br><span class="line">            raise TypeError(f&#39;the JSON object must be str, bytes or bytearray, &#39;</span><br><span class="line">                            f&#39;not &#123;s.__class__.__name__&#125;&#39;)</span><br><span class="line">        s &#x3D; s.decode(detect_encoding(s), &#39;surrogatepass&#39;)</span><br><span class="line"></span><br><span class="line">    if &quot;encoding&quot; in kw:</span><br><span class="line">        import warnings</span><br><span class="line">        warnings.warn(</span><br><span class="line">            &quot;&#39;encoding&#39; is ignored and deprecated. It will be removed in Python 3.9&quot;,</span><br><span class="line">            DeprecationWarning,</span><br><span class="line">            stacklevel&#x3D;2</span><br><span class="line">        )</span><br><span class="line">        del kw[&#39;encoding&#39;]</span><br><span class="line"></span><br><span class="line">    if (cls is None and object_hook is None and</span><br><span class="line">            parse_int is None and parse_float is None and</span><br><span class="line">            parse_constant is None and object_pairs_hook is None and not kw):</span><br><span class="line">        return _default_decoder.decode(s)</span><br><span class="line">    if cls is None:</span><br><span class="line">        cls &#x3D; JSONDecoder</span><br><span class="line">    if object_hook is not None:</span><br><span class="line">        kw[&#39;object_hook&#39;] &#x3D; object_hook</span><br><span class="line">    if object_pairs_hook is not None:</span><br><span class="line">        kw[&#39;object_pairs_hook&#39;] &#x3D; object_pairs_hook</span><br><span class="line">    if parse_float is not None:</span><br><span class="line">        kw[&#39;parse_float&#39;] &#x3D; parse_float</span><br><span class="line">    if parse_int is not None:</span><br><span class="line">        kw[&#39;parse_int&#39;] &#x3D; parse_int</span><br><span class="line">    if parse_constant is not None:</span><br><span class="line">        kw[&#39;parse_constant&#39;] &#x3D; parse_constant</span><br><span class="line">    return cls(**kw).decode(s)</span><br></pre></td></tr></table></figure><p><code>loads()</code>의 파라미터부터 보겠습니다. 첫 번째 파라미터 <code>s</code>는 JSON 문서를 포함하고 있는 <code>str</code>, <code>bytes</code>, <code>bytearray</code>를 말합니다.</p><p>입력받은 <code>s</code>의 타입 검사부터 시작합니다. <code>str</code>, <code>bytes</code>, <code>bytearray</code> 셋 중 하나에 해당하지 않으면 TypeError를 일으킵니다.</p><p><code>encoding</code>의 경우 deprecated 된 파라미터이기에 경고 문구를 나타내고 키워드 파라미터로부터 삭제합니다. <code>cls</code> 가 입력된 경우엔 기본 Decoder인 <code>JSONDecoder</code>를 사용하지 않고 입력받은 Decoder를 사용하여 Deserialize합니다. <code>loads()</code> 메소드 역시 입력받은 파라미터를 가지고 JSONDecoder의 <code>decode()</code> 메소드를 호출하는 역할이기에 타입 검사 이외의 로직은 보이지 않습니다.</p><p><code>__init__.py</code>의 설명은 이렇게 끝났습니다. 전체 370 라인을 가지고 있지만 대부분이 주석 및 예제로 이루어져 있기에 실제 코드의 양을 얼마 되지 않아 금방 볼 수 있었습니다.</p><p>다음으로는 <code>encoder.py</code>를 보겠습니다.</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>파이썬 코드 읽어보기 - json/tool.py</title>
      <link href="/python/code-reading-json-tool/"/>
      <url>/python/code-reading-json-tool/</url>
      
        <content type="html"><![CDATA[<h1 id="json-JSON-encoder-and-decoder"><a href="#json-JSON-encoder-and-decoder" class="headerlink" title="json - JSON encoder and decoder"></a>json - JSON encoder and decoder</h1><ul><li>출처 : <a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">https://docs.python.org/3/library/json.html</a></li><li>코드 : <a href="https://github.com/python/cpython/blob/3.7/Lib/json/tool.py" target="_blank" rel="noopener">https://github.com/python/cpython/blob/3.7/Lib/json/tool.py</a></li></ul><p><strong>파이썬 코드 읽어보기</strong> 첫 번째 시리즈는 <code>json</code>입니다. </p><p><code>import json</code></p><p>개발 중 흔하게 만나던 <code>json</code>의 내부는 어떻게 되어 있는지 같이 확인해봅시다. </p><p>저는 <a href="https://github.com/python/cpython/blob/3.7/Lib/json/tool.py" target="_blank" rel="noopener">cpython repository</a>에서 코드를 확인해봤습니다. 파이썬 코드는 ./Lib/ 디렉토리 아래에서 확인할 수 있습니다.</p><p><code>cpython/Lib/json/</code> 디렉토리안의 내용입니다.</p><ul><li><code>__init__.py</code></li><li><code>decoder.py</code></li><li><code>encoder.py</code></li><li><code>scanner.py</code></li><li><code>tool.py</code></li></ul><p>본 글에서는 <code>tool.py</code>를 확인해보겠습니다.</p><h3 id="tool-py"><a href="#tool-py" class="headerlink" title="tool.py"></a><code>tool.py</code></h3><p>메소드 및 주요 변수 중심으로 천천히 설명하겠습니다. 50여줄의 간단한 코드이지만, 커맨드라인을 통해 파이썬 모듈을 실행할 수 있도록 하는 <code>argparse</code>의 사용법을 본 파일을 통해 확인할 수 있었습니다.</p><p><code>tool.py</code> 는 JSON의 validation, pretty print을 도와주는 커맨드라인 툴입니다. </p><p>사용예</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#39;&#123;&quot;json&quot;:&quot;obj&quot;&#125;&#39; | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    &quot;json&quot;: &quot;obj&quot;</span><br><span class="line">&#125;</span><br><span class="line">$ echo &#39;&#123; 1.2:3.4&#125;&#39; | python -m json.tool</span><br><span class="line">Expecting property name enclosed in double quotes: line 1 column 3 (char 2)</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p><code>tool.py</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import argparse</span><br><span class="line">import json</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    prog &#x3D; &#39;python -m json.tool&#39;</span><br><span class="line">    description &#x3D; (&#39;A simple command line interface for json module &#39;</span><br><span class="line">                   &#39;to validate and pretty-print JSON objects.&#39;)</span><br><span class="line">    parser &#x3D; argparse.ArgumentParser(prog&#x3D;prog, description&#x3D;description)</span><br><span class="line">    parser.add_argument(&#39;infile&#39;, nargs&#x3D;&#39;?&#39;, type&#x3D;argparse.FileType(),</span><br><span class="line">                        help&#x3D;&#39;a JSON file to be validated or pretty-printed&#39;,</span><br><span class="line">                        default&#x3D;sys.stdin)</span><br><span class="line">    parser.add_argument(&#39;outfile&#39;, nargs&#x3D;&#39;?&#39;, type&#x3D;argparse.FileType(&#39;w&#39;),</span><br><span class="line">                        help&#x3D;&#39;write the output of infile to outfile&#39;,</span><br><span class="line">                        default&#x3D;sys.stdout)</span><br><span class="line">    parser.add_argument(&#39;--sort-keys&#39;, action&#x3D;&#39;store_true&#39;, default&#x3D;False,</span><br><span class="line">                        help&#x3D;&#39;sort the output of dictionaries alphabetically by key&#39;)</span><br><span class="line">    parser.add_argument(&#39;--json-lines&#39;, action&#x3D;&#39;store_true&#39;, default&#x3D;False,</span><br><span class="line">                        help&#x3D;&#39;parse input using the jsonlines format&#39;)</span><br><span class="line">    options &#x3D; parser.parse_args()</span><br><span class="line"></span><br><span class="line">    infile &#x3D; options.infile</span><br><span class="line">    outfile &#x3D; options.outfile</span><br><span class="line">    sort_keys &#x3D; options.sort_keys</span><br><span class="line">    json_lines &#x3D; options.json_lines</span><br><span class="line">    with infile, outfile:</span><br><span class="line">        try:</span><br><span class="line">            if json_lines:</span><br><span class="line">                objs &#x3D; (json.loads(line) for line in infile)</span><br><span class="line">            else:</span><br><span class="line">                objs &#x3D; (json.load(infile), )</span><br><span class="line">            for obj in objs:</span><br><span class="line">                json.dump(obj, outfile, sort_keys&#x3D;sort_keys, indent&#x3D;4)</span><br><span class="line">                outfile.write(&#39;\n&#39;)</span><br><span class="line">        except ValueError as e:</span><br><span class="line">            raise SystemExit(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parser &#x3D; argparse.ArgumentParser(prog&#x3D;prog, description&#x3D;description)</span><br></pre></td></tr></table></figure><p><code>prog</code> - 프로그램의 이름</p><p><code>description</code> - 프로그램의 상세 내용 설명</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python -m json.tool -h</span><br><span class="line">usage: python -m json.tool [-h] [--sort-keys] [infile] [outfile]</span><br><span class="line"></span><br><span class="line">A simple command line interface for json module to validate and pretty-print</span><br><span class="line">JSON objects.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  infile       a JSON file to be validated or pretty-printed</span><br><span class="line">  outfile      write the output of infile to outfile</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help   show this help message and exit</span><br><span class="line">  --sort-keys  sort the output of dictionaries alphabetically by key</span><br></pre></td></tr></table></figure><p><code>python -m</code> : <code>-m</code> 플래그를 사용하면 파이썬의 라이브러리를 직접 실행 시킬 수 있습니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(...)</span><br><span class="line">options &#x3D; parser.parse_args()</span><br></pre></td></tr></table></figure><p><code>add_argument()</code>를 통해 해당 프로그램이 처리 할 수 있는 인수를 추가합니다. 그리고 난 후 <code>parse_args()</code> 를 통해 입력받은 인수를 변수에 할당합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">with infile, outfile:</span><br><span class="line">        try:</span><br><span class="line">            if json_lines:</span><br><span class="line">                objs &#x3D; (json.loads(line) for line in infile)</span><br><span class="line">            else:</span><br><span class="line">                objs &#x3D; (json.load(infile), )</span><br><span class="line">            for obj in objs:</span><br><span class="line">                json.dump(obj, outfile, sort_keys&#x3D;sort_keys, indent&#x3D;4)</span><br><span class="line">                outfile.write(&#39;\n&#39;)</span><br><span class="line">        except ValueError as e:</span><br><span class="line">            raise SystemExit(e)</span><br></pre></td></tr></table></figure><p>위 부분의 흐름을 보면 <code>json.loads()</code> 로 생성된 <code>objs</code>를 <code>json.dump()</code> 하고 있습니다.</p><p>즉 문자열 입력을 받아 파이썬 오브젝트로 변환한 후 다시 파이썬 오브젝트를 파일에 직렬화하여 출력하고 있습니다.</p><p>이걸로 <code>json</code> 모듈 훑어보기가 끝났습니다. </p><p>감사합니다.</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>육아 휴직 3개월</title>
      <link href="/dairy/Child-care-leave-3-month/"/>
      <url>/dairy/Child-care-leave-3-month/</url>
      
        <content type="html"><![CDATA[<h1 id="육아휴직-3개월"><a href="#육아휴직-3개월" class="headerlink" title="육아휴직 3개월!"></a>육아휴직 3개월!</h1><p>2019년 7월 1일부터 9월 30일까지 육아 휴직을 명 받았습니다.<br>길다면 길고 짧다면 짧은 3개월 어떻게 써야할지 고민이 되어 생각을 정리해보고자 글을 적어봅니다.</p><p>2017년 11월에 입사한 뒤 1년 7개월간 이것 저것 손도 대보고 사고도 쳐 보면서 많이 배웠습니다. 하지만 지금 머릿속에 남아있는건 최근에 작업한 녀석들이 대부분인 것 같아 아쉽기도 합니다.(많이 남은게 없어서 아쉽다는 뜻이죠)</p><h2 id="매일-루틴"><a href="#매일-루틴" class="headerlink" title="매일 루틴"></a>매일 루틴</h2><p>제가 육아휴직 사용하는 것을 처음엔 아내가 반대했었는데요. 그 이유는 저의 일본어, 영어 회화 실력이 낮기 때문이죠. 부끄럽지만 지금도 겨우 소통하는 수준인데, 3개월을 통으로 쉬고 나면 다시 복직해서 회복기가 꽤나 길어질듯 싶어 그랬나 싶습니다. 외국인 노동자로서 의사소통 능력은 기본 중의 기본이기에 쉬는 동안에도 잊지 않도록 열심히 해야겠습니다.</p><ol><li>매일 NHK Podcast 듣고 받아 적기.</li></ol><ul><li>거의 매 시각 업데이트 되는 NHK Podcast를 가끔 출근하면서 듣기도 했는데요, 최근에는 BTS에 빠져서 노래를 들으며 출근을 했었죠. 다시 초심으로 돌아가서 1일 1에피소드 제대로 소화해보도록 하겠습니다.(효과는 미미했다?)</li></ul><ol start="2"><li><p>영어, 스피킹 능력 향상<br><a href="https://www.facebook.com/groups/helpdev/" target="_blank" rel="noopener">개발자해외취업, Korean Software Engineers</a> 이라는 그룹에서 관리자 Neo Minchul Chae님이 공유하고 계신 ‘개발자매일영어’라는 프로그램을 따라해보려 합니다. 이전부터 관심은 있었으니 계속 관심수준에만 머물러있었는데, 이번에야말로 저도 같이 동참해보고 싶습니다. 관리자님께 꾸준히 자료 공유해주셔서 감사하다는 말씀 전하고 싶습니다.(나중에 직접 전하겠습니다 ㅎ)</p></li><li><p>개발책 꾸준히 보기, 컨퍼런스 많이 참여하기<br>굉장히 애매한 단어들(개발책, 꾸준히)로 구성된 항목인데, 그냥 평소처럼 책 보고 따라 쳐보고 토이 프로젝트 만들고 글 쓰는 활동을 하려고 합니다. 일하는 동안에는 가고 싶었던 컨퍼런스에 다 가지는 못했었는데, 이번 3개월 만큼은 한국 일본 양국을 오가며 가능한 많이 가보고 싶습니다.  </p></li></ol><p>이 정도만 제대로 해도 꽤나 충실한 3개월이 될듯 싶은데요. 과연 얼마나 지속할 수 있을지, 지속했다면 내용 및 결과면에서도 부끄럽지 않은 3개월이 되었으면 합니다. </p><h2 id="7월-복습"><a href="#7월-복습" class="headerlink" title="7월 - 복습"></a>7월 - 복습</h2><p>첫 한 달이네요. 일단 좀 쉬고 싶기도 하지만 처음으로 세상을 마주하고 있는 우리 딸이 제가 쉬도록 허락해주질 않을 듯 싶습니다. 그리고 한국에 계신 부모님에게 첫 손주도 보여드려야 하니 이래 저래 바쁠듯 하지만!<br>입사 후 1년 7개월 간 배운 것들을 정리하려 합니다. 주로 Java, Spring, Vue.js, Nuxt.js, Kubernetes 정도가 메인 키워드가 될 듯 싶습니다.<br>적어도 7월의 절반 이상은 한국에 있을 것 같은데, 쉬기만 하지 않고 충실하게 복습할 수 있는 한 달이 될 수 있도록 철저한 계획과 함께 시작하려합니다. </p><h2 id="8월"><a href="#8월" class="headerlink" title="8월"></a>8월</h2><p>Istio</p><ul><li>이미 업계 내에서 부상한지는 꽤 된것 같은데요, 부끄럽게도 아직 제대로 공식 홈페이지조차 읽어보지 못했습니다.</li></ul><p>Graphql</p><ul><li>새로운 패러다임이 될 수 있을까요? 일단 파보려합니다. 판다고 해도 깊게 파는건 아니지만요.</li></ul><p>Google Cloud Platform 관련 자격증 공부</p><ul><li>회사 내 골 세팅 중 하나이기도 한 GCP 자격증 취득!</li></ul><p>Python</p><ul><li>전문가를 위한 파이썬(책)</li><li>클린코드를 위한 테스트 주도 개발(책)</li></ul><p>Pycon KR 참여</p><ul><li>얼리버드 티켓은 샀습니다만, 비행기 티켓은 살 수 있을지 잘 모르겠네요.</li><li>스프린트를 한 번 참여해보고 싶지만, 얼리버드는 그게 안되서 다시 구매해야할 수도…</li></ul><h2 id="9월"><a href="#9월" class="headerlink" title="9월"></a>9월</h2><p>아직 미정입니다만, 뭔가 해야겠죠?</p>]]></content>
      
      
      <categories>
          
          <category> dairy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 육아휴직 </tag>
            
            <tag> 연장 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>아는 것과 해본 것의 차이</title>
      <link href="/thought/difference-between-know-did/"/>
      <url>/thought/difference-between-know-did/</url>
      
        <content type="html"><![CDATA[<p>최근 지인과의 대화 중 그가 나에게 OO대해 알고 있는지 물어봤다.<br>간단하게 알고 있는 수준에서 대답은 했지만, 그 뒤 내가 무엇을 알고 무엇을 모르는지에 대해 알고 싶어졌다.</p><p>소위 말하는 <a href="https://ko.wikipedia.org/wiki/%EB%A9%94%ED%83%80%EC%9D%B8%EC%A7%80" target="_blank" rel="noopener">메타인지</a>인데, 생각에 대한 생각, 인지에 대한 인지라고 위키피디아는 말한다. </p><p>프로그래밍에 있어 OO에 대해 안다는 것은 무엇인가.</p><p>안다. </p><ol><li>정의</li><li>공식 문서의 Getting Started를 읽고 실행</li><li>공식 문서의 많은 부분을 파악</li><li>프로덕션 레벨에서 사용(물론 이 안에서도 수없이 많이 구분될 수 있다고 생각)</li><li>소스코드의 대부분을 파악</li><li>만약 오픈소스라면 공헌</li><li>내가 만든 프로그램 </li></ol><p>nginx에 대해 아는가? Spring에 대해 아는가? 둘 다 실제 서비스 환경에서 사용한 기술들이지만 어디가서 알고 있다고 말하기가 부끄럽다. </p><p>처음 개발에 입문한 후 이력서를 쓰기 시작했을 때, 나의 이력서 속 보유 기술란은 칸이 모자랄 정도였다.<br>HTML, CSS, Javascript, MySQL, NGINX, Google App engine, Python, Flask, SqlAlchemy, … 등등 나를 스쳐갔던 모든 것이 너나 할 것 없이 그 자리에 있길 원했다.<br>보잘것 없는 실력을 숨기고 어떻게든 일자리를 얻기 위해서였을까? 정말로 그 시절의 내가 알고 있다고 믿었던 것일까? </p><p>4~5년이 지난 지금 기억하려해도 잘 기억나지 않지만, 현재 나는 위에 쓰여진 기술 중 그 어떤것도 잘 알고 있다고 하지 않는다.<br>‘다만 사용해본적이 있다’정도의 약간은 자기 방어적인 말로 언제있을지 모르는 추궁에 대비한다. </p><p>지금 만약 다시 이력서를 쓴다면, 첫 이력서에 있던 보유 기술들은 대부분 지워지고 한 두가지의 언어와 프레임워크가 남아 있을 것이다.<br>쓰여진 기술들에 대해 잘 알고 있냐고 물어본다면 역시나 나의 대답은 “몇 번 써본적이 있다”로 끝을 맺을것이다. </p><p><a href="http://blog.lastmind.io/archives/593" target="_blank" rel="noopener">Dreyfus Model</a><br><a href="https://docs.google.com/document/d/1_phA5XUszSmN7Ta-QHs4DxRz9_iu8YlhxpVjSGEbWcg/edit?fbclid=IwAR0-I5kvHcDUkhPUCvPwzORYD8Qfm6rz_RkPiz066y_VFkfO5SuENG0RYWE" target="_blank" rel="noopener">능력있는 개발자는 어떻게 알아 볼 수 있나?</a><br><a href="https://en.wikipedia.org/wiki/Dreyfus_model_of_skill_acquisition" target="_blank" rel="noopener">Dreyfus model of skill acquisition</a><br><a href="https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect" target="_blank" rel="noopener">더닝크루거효과</a></p>]]></content>
      
      
      <categories>
          
          <category> thought </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>voyagerx interview 01</title>
      <link href="/interview/voyagerx-1/"/>
      <url>/interview/voyagerx-1/</url>
      
        <content type="html"><![CDATA[<h2 id="모든-개발자-공통-기술-질문"><a href="#모든-개발자-공통-기술-질문" class="headerlink" title="모든 개발자 공통 기술 질문"></a>모든 개발자 공통 기술 질문</h2><h3 id="PNG와-JPG의-차이점은"><a href="#PNG와-JPG의-차이점은" class="headerlink" title="PNG와 JPG의 차이점은?"></a>PNG와 JPG의 차이점은?</h3><h4 id="검색-전"><a href="#검색-전" class="headerlink" title="검색 전"></a>검색 전</h4><ul><li>공통점부터 말하자면, 둘 다 이미지를 표현하기 위한 파일 형식.</li><li>PNG, Portable Network Graphic의 약자인데 솔직히 검색해보기 전까지는 Portable까지 밖에 알지 못했다. Portable이란 이름에서 유추할 수 있듯이 웹에 게재 혹은 전송되기 적합해 보인다. </li><li>JPG, JPEG을 JPG라 부른다는 정도 밖에 알지 못함.</li></ul><h4 id="검색-후"><a href="#검색-후" class="headerlink" title="검색 후"></a>검색 후</h4><p>각각의 정의(from wikipedia) </p><ul><li>JPEG : 디지털 이미지를 위한 손실 압축의 한 종류, 손실 정도는 조절 될 수 있다. 이는 사진의 질과 파일 용량간의 트레이드 오프가 존재함을 의미한다. </li><li>PNG : PNG는 레스터 그래픽 파일 포맷으로 무손실 압축을 지원하며 또한 GIF 포맷을 대체하기 위해 개발되었다고 한다.</li></ul><p>가장 큰 차이는 압축 방식으로 JPEG은 압축과정 중 원본의 손실이 일어나는 반면 PNG는 손실 없이 이미지 데이터를 저장할 수 있다. 웹 개발자로서는 어떤 파일 포맷이 화면상에 같게 보이는 이미지를 더 작은 크기로 전달 할 수 있는가라고 생각한다.</p><p>참고 링크</p><ul><li><a href="https://en.wikipedia.org/wiki/JPEG" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/JPEG</a></li><li><a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Portable_Network_Graphics</a></li><li><a href="https://stackoverflow.com/questions/2336522/what-are-the-different-usecases-of-png-vs-gif-vs-jpeg-vs-svg" target="_blank" rel="noopener">https://stackoverflow.com/questions/2336522/what-are-the-different-usecases-of-png-vs-gif-vs-jpeg-vs-svg</a></li></ul><h3 id="Dynamic-Programming이란"><a href="#Dynamic-Programming이란" class="headerlink" title="Dynamic Programming이란?"></a>Dynamic Programming이란?</h3><h4 id="검색-전-1"><a href="#검색-전-1" class="headerlink" title="검색 전"></a>검색 전</h4><ul><li>동적 프로그래밍, 알고리즘 문제 풀 때 보긴 했지만 정확히는 잘 모르겠다. 메모이제이션(Memoization) 통해 문제 해결을 하긴 했던걸로 기억하는데…</li></ul><h4 id="검색-후-1"><a href="#검색-후-1" class="headerlink" title="검색 후"></a>검색 후</h4><p>참고 링크</p><ul><li><p><a href="https://en.wikipedia.org/wiki/Dynamic_programming" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Dynamic_programming</a></p></li><li><p>Virtual Memory란?</p></li><li>Garbage Collection이란?</li><li>Cache란?</li><li>Database Index 추가의 장단점은?</li><li>비대칭 암호화란?</li><li>HDD, SSD, DRAM 각각의 성능은?</li><li>GIT의 장점은?</li></ul><h2 id="백엔드-개발자-기술-질문"><a href="#백엔드-개발자-기술-질문" class="headerlink" title="백엔드 개발자 기술 질문"></a>백엔드 개발자 기술 질문</h2><ul><li>공유기의 원리는?</li><li>HTTP/2의 특징은?</li><li>Node.js의 특징은?</li><li>NoSQL의 장단점은?</li><li>Semaphore란?</li><li>Memory Leak 디버깅은?</li><li>CDN의 역할은?</li><li>Kubernetes는 왜 인기인가?</li><li>Infrastructure as code의 장점은?</li></ul><h2 id="모든-개발자-공통-요건"><a href="#모든-개발자-공통-요건" class="headerlink" title="모든 개발자 공통 요건"></a>모든 개발자 공통 요건</h2><ul><li>개발을 좋아함</li><li>수학을 좋아함</li><li>딥러닝에 관심이 많음</li><li>협업이 두렵지 않음</li><li>책임감이 강함</li></ul><h2 id="백엔드-개발자-공통-요건"><a href="#백엔드-개발자-공통-요건" class="headerlink" title="백엔드 개발자 공통 요건"></a>백엔드 개발자 공통 요건</h2><ul><li>사용자를 생각하며 개발함</li><li>백엔드 개발에 보람을 느낌</li><li>서버 운영도 같이 할 수 있음</li><li>더 빨리 더 잘 만들 수 없을까 고민함</li><li>완벽만큼 완성을 중요하게 생각함</li></ul><h2 id="추가-중복주의"><a href="#추가-중복주의" class="headerlink" title="추가 (중복주의)"></a>추가 (중복주의)</h2><p><a href="https://www.notion.so/Career-at-VoyagerX-d3c334b287494f3a81d9991c892dd582" target="_blank" rel="noopener">채용페이지 링크</a></p><ul><li style="list-style: none"><input type="checkbox"></input> PNG와 JPG의 차이점은?</li><li style="list-style: none"><input type="checkbox"></input> Dynamic Programming이란?</li><li style="list-style: none"><input type="checkbox"></input> Virtual Memory란?</li><li style="list-style: none"><input type="checkbox"></input> Semaphore란?</li><li style="list-style: none"><input type="checkbox"></input> Cache란?</li><li style="list-style: none"><input type="checkbox"></input> Garbage Collection이란?</li><li style="list-style: none"><input type="checkbox"></input> Database Index 추가의 장단점은?</li><li style="list-style: none"><input type="checkbox"></input> NoSQL의 장단점은?</li><li style="list-style: none"><input type="checkbox"></input> 공유기의 원리는?</li><li style="list-style: none"><input type="checkbox"></input> HTTP/2의 특성은?</li><li style="list-style: none"><input type="checkbox"></input> 비대칭 암호화란?</li><li style="list-style: none"><input type="checkbox"></input> Node.js의 특징은?</li><li style="list-style: none"><input type="checkbox"></input> HDD, SSD, DRAM 각각의 성능은?</li><li style="list-style: none"><input type="checkbox"></input> Memory Leak 디버깅은?</li><li style="list-style: none"><input type="checkbox"></input> GIT의 장점은?</li></ul>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> 남세동 </tag>
            
            <tag> Voyagerx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>프로페셔널의 조건 - 피터 드러커</title>
      <link href="/book/The-Essential-Drucker/"/>
      <url>/book/The-Essential-Drucker/</url>
      
        <content type="html"><![CDATA[<h1 id="프로페셔널의-조건-피터-드러커-지음"><a href="#프로페셔널의-조건-피터-드러커-지음" class="headerlink" title="프로페셔널의 조건, 피터 드러커 지음"></a>프로페셔널의 조건, 피터 드러커 지음</h1><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li>새로운 사회의 거대한 변화</li></ol><ul><li>지식의 전환과 지식 사회</li><li>조직 사회와 지식 근로자</li></ul><ol start="2"><li>지식 노동과 지식 근로자의 생산성</li></ol><ul><li>생산성을 어떻게 향상시킬 것인가</li><li>어떻게 성과를 올릴 것인가</li><li>공헌할 목표에 초점을 맞추어라</li></ul><ol start="3"><li>프로페셔널로서의 자기 관리</li></ol><ul><li>인생을 바꾼 7가지 지적 경험</li><li>자신의 강점을 파악하라</li><li>시간을 관리하는 방법</li><li>중요한 일에 집중하라</li></ul><ol start="4"><li>프로페셔널을 위한 몇 가지 기초 지식</li></ol><ul><li>효과적인 의사 결정 방법</li><li>조직 내에서의 커뮤니케이션 방법</li><li>정보 중심 조직의 특성</li><li>리더십은 어떻게 발휘하는가</li><li>강점을 활용하는 방법</li><li>경영 혁신의 원리와 방법</li></ul><ol start="5"><li>자기 실현을 향한 도전</li></ol><ul><li>인생의 후반부를 준비하라</li><li>교육받은 사람이란 누구인가</li><li>어떤 사람으로 기억되기 바라는가</li></ul>]]></content>
      
      
      <categories>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 피터드러커 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>라이브 아카데미, &quot;내가 알기로는&quot;, &quot;내가 듣기로는&quot;, &quot;내가 보기에는&quot; - 자연스러운 영어를 위한 필수 표현 3가지 정리</title>
      <link href="/youtube-review/live-academy-corrections-for-natural-english/"/>
      <url>/youtube-review/live-academy-corrections-for-natural-english/</url>
      
        <content type="html"><![CDATA[<h2 id="관련링크"><a href="#관련링크" class="headerlink" title="관련링크"></a>관련링크</h2><ul><li><a href="https://youtu.be/_iGn9DGWvIE" target="_blank" rel="noopener">영어회화 | 시급한 교정 | “내가 알기로는”, “내가 듣기로는”, “내가 보기에는” - 자연스러운 영어를 위한 필수 표현 3가지</a></li></ul><h2 id="학습-내용"><a href="#학습-내용" class="headerlink" title="학습 내용"></a>학습 내용</h2><h3 id="1-내가-알기로는"><a href="#1-내가-알기로는" class="headerlink" title="1. 내가 알기로는"></a>1. 내가 알기로는</h3><p>Right expression</p><ul><li>as far as I know(understand)</li></ul><p>이하 3개의 표현은 격식을 갖춰 말할 때 </p><ul><li>based on + <ul><li>based on what I know(understand)</li></ul></li><li>according to + </li><li>to my knowledge </li></ul><p>As far as I know, that movie is releasing this week.</p><p>Wrong expression</p><ul><li>As I know</li></ul><h3 id="2-내가-듣기로는"><a href="#2-내가-듣기로는" class="headerlink" title="2. 내가 듣기로는"></a>2. 내가 듣기로는</h3><p>가장 편하게 쓸 수 있는 것</p><ul><li>from what I hear(heard) </li><li>from what I’ve heard<br>시제에 따라 뉘앙스는 조금 다르다.</li></ul><p>as far as I’ve heard </p><p>공개된 내용이 아닌 - 나에게 개인적으로 전달된 얘기에 대해서는 I was told (that) + 라고 흔히 표현한다.<br>제가 듣기로는 올해에도 똑같을거래요.<br>I was told that it would be the same this year.</p><h3 id="3-내가-보기에는"><a href="#3-내가-보기에는" class="headerlink" title="3. 내가 보기에는"></a>3. 내가 보기에는</h3><p>자신의 판단, 관점을 기반으로 이야기할때 </p><ul><li>The way I see it,</li><li>As far as I can tell(말하다-x, 판단하다-o), …</li></ul><p>내가 보기에는 타이밍이 문제였어.<br>The way I see it, the timing was the problem.<br>As far as I can tell, the timing was the problem. </p><p>내 생각에는 </p><ul><li>In my opinion </li><li>I think</li></ul><p>Wrong expression</p><ul><li>in my thinking(X)</li></ul>]]></content>
      
      
      <categories>
          
          <category> youtube-review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 영어 </tag>
            
            <tag> 빨간모자 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Youtuber Introduction, Julius Chun</title>
      <link href="/youtube-review/juliuschun-introduction/"/>
      <url>/youtube-review/juliuschun-introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="관련링크"><a href="#관련링크" class="headerlink" title="관련링크"></a>관련링크</h2><ul><li><a href="https://blog.naver.com/juliuschun" target="_blank" rel="noopener">블로그</a></li><li><a href="https://www.youtube.com/channel/UChdVrewKcV9b_PMmvscTdGg" target="_blank" rel="noopener">유투브</a></li><li><a href="https://www.boolio.co.kr/" target="_blank" rel="noopener">불리오</a></li></ul><h2 id="추천-동영상"><a href="#추천-동영상" class="headerlink" title="추천 동영상"></a>추천 동영상</h2><ul><li><a href="https://youtu.be/sUfDcepDyKU" target="_blank" rel="noopener">억대 연봉, 나도 받을 수 있을까? (1)</a></li><li><a href="https://youtu.be/AGD_BDJCjAE" target="_blank" rel="noopener">억대 연봉, 나도 받을 수 있을까? (2)</a></li><li><a href="https://youtu.be/fSWwfBfPyNM" target="_blank" rel="noopener">억대 연봉, 나도 받을 수 있을까? (3)</a></li></ul><ol><li>마음을 먹어야 한다</li><li>기하급수의 세계를 인정하자<br><img src="/images/youtube-review/exponential.png" alt="기하급수"></li><li>직접 체험해야 한다</li><li>올인하는 시기의 필요성</li><li>자기계발에 투입하는 시간<ul><li>어떤 방식으로든 자기 자신에게 투자하는 시간이 있어야 한다.</li><li>모두가 기본적으로 5-10% 성장을 한다.</li><li>스스로 자기 자신을 성장시키는것 만이 차별화의 핵심.</li><li>업계에서 월등히 잘하는, 세계 레벨의 사람의 사례를 보면 꿈을 키우자.</li></ul></li><li>억대 연봉, 그리고 수요자 시장<ul><li>수요와 공급의 역전이 일어난다.</li><li>1분 1초, 자기 자신의 실력을 키우는데 집중하자.</li><li>낭중지추, 평균으로부터 멀어질수록 자연히 돋보이게 된다.</li></ul></li><li>콘텐츠로 자신을 알리기<ul><li>다양한 채널을 통해 나 자신이 얻었던 인사이트, 지식을 공유하라.</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> youtube-review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 천영록 </tag>
            
            <tag> 부의확장 </tag>
            
            <tag> 불리오 </tag>
            
            <tag> 불릴레오 </tag>
            
            <tag> 두물머리 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>라이브 아카데미, 영어 학습법 정리</title>
      <link href="/youtube-review/live-academy-ways-to-learn-english/"/>
      <url>/youtube-review/live-academy-ways-to-learn-english/</url>
      
        <content type="html"><![CDATA[<h2 id="관련링크"><a href="#관련링크" class="headerlink" title="관련링크"></a>관련링크</h2><ul><li><a href="https://www.youtube.com/playlist?list=PLIsIUJcT0HIUAtaC3xx5iPs83PGFSt6Ke" target="_blank" rel="noopener">유투브, 라이브아카데미 - 학습가이드</a></li></ul><h2 id="학습가이드-01-영어회화-영어공부에-대한-오해와-올바른-방법"><a href="#학습가이드-01-영어회화-영어공부에-대한-오해와-올바른-방법" class="headerlink" title="학습가이드 #01 | 영어회화, 영어공부에 대한 오해와 올바른 방법"></a>학습가이드 #01 | 영어회화, 영어공부에 대한 오해와 올바른 방법</h2><ul><li>연습의 중요성 : 평소 몸에 완전히 익힌 표현만 실전에서 사용할 수 있다.</li></ul><h3 id="To-Do"><a href="#To-Do" class="headerlink" title="To-Do"></a>To-Do</h3><ul><li>배운 내용을 평소에 연습할 수 있도록 루틴을 만들기</li></ul><h2 id="학습가이드-02-2018년-영어를-배우는-사람들을-위한-메시지-amp-Tip"><a href="#학습가이드-02-2018년-영어를-배우는-사람들을-위한-메시지-amp-Tip" class="headerlink" title="학습가이드 #02 | 2018년 영어를 배우는 사람들을 위한 메시지 &amp; Tip!"></a>학습가이드 #02 | 2018년 영어를 배우는 사람들을 위한 메시지 &amp; Tip!</h2><ul><li>좋은 학습법이 학습량을 줄여주지 않는다. 왕도는 없다. </li><li>학습을 위한 루틴 : Weekly Exercise Routine<ul><li>적절한 레벨의 루틴을 정하는 것이 중요. Not too much</li><li>인풋과 아웃풋의 비율이 중요. </li><li>Take a break, 페이스 조절</li><li>요일별 공부 주제를 정해두는 것이 큰 도움이 된다.</li></ul></li></ul><h3 id="To-Do-1"><a href="#To-Do-1" class="headerlink" title="To-Do"></a>To-Do</h3><ul><li>Set up a weekly routine</li></ul><h2 id="학습가이드-03-영어를-배우는-사람들의-3가지-유형"><a href="#학습가이드-03-영어를-배우는-사람들의-3가지-유형" class="headerlink" title="학습가이드 #03 | 영어를 배우는 사람들의 3가지 유형"></a>학습가이드 #03 | 영어를 배우는 사람들의 3가지 유형</h2><ol><li>이상형</li></ol><ul><li>특정 어휘, 표현이 마음에 들면 해당 어휘를 충분히 사용한다. </li><li>일주일에 어휘, 표현 1,2개로 충분.</li><li>단순히 외우는 것이 아닌 응용할 수 있는 레벨.</li></ul><ol start="2"><li>보물 사냥꾼형</li></ol><ul><li>최고의 강사, 최고의 학습법 등 효율적인 방법을 찾는 타입.</li><li>There is no silver bullet.</li><li>누군가 영어를 잘하는 사람(학습자)을 만났을 때, 절대 부러워 하지 말라. 나 역시 그처럼 될 수 있도록 열심히 공부해야 겠다는 생각을 대신 하자.</li></ul><ol start="3"><li>좀비형</li></ol><ul><li>일정 기간 단위로 자신의 실력이 향상 했는지를 확인해보자.</li><li>단순히 영어를 배우는 나 자신에 심취한 것인지, 아닌지 알아보아야함.</li><li>셀프 피드백, 외부의 피드백 등이 필요함.</li></ul><h3 id="To-Do-2"><a href="#To-Do-2" class="headerlink" title="To-Do"></a>To-Do</h3><p>Be the first type English learner of upper lists.</p><h2 id="학습가이드-04-더-효과적인-학습을-위해서-배우는-습관을-조금-바꾸자"><a href="#학습가이드-04-더-효과적인-학습을-위해서-배우는-습관을-조금-바꾸자" class="headerlink" title="학습가이드 #04 | 더 효과적인 학습을 위해서 배우는 습관을 조금 바꾸자"></a>학습가이드 #04 | 더 효과적인 학습을 위해서 배우는 습관을 조금 바꾸자</h2><ul><li>문법을 이해하고 학습을 하는데 너무 많은 시간을 보내거나 의존하지 말자.</li><li>비슷한 말들의 차이점을 모두 이해하고 외우려 하지 말자.<ul><li>example) erase, delete, remove, get rid of</li></ul></li></ul><h2 id="학습가이드-05-영어표현이-와닿지-않는다고-피하지-마세요"><a href="#학습가이드-05-영어표현이-와닿지-않는다고-피하지-마세요" class="headerlink" title="학습가이드 #05 - 영어표현이 와닿지 않는다고 피하지 마세요"></a>학습가이드 #05 - 영어표현이 와닿지 않는다고 피하지 마세요</h2><ul><li>원래 처음부터 잘 와닿는 영어 표현은 많지 않다.</li><li>현재 익숙하게 느껴지는 영어 표현은 과거에 충분히 연습했거나, 많이 들었던 표현.</li><li>와닿지 않는 표현 일수록 더 연습해보자. 단지 한국어의 표현 방식, 접근 방식과 차이가 큰 것일 뿐.</li></ul><h2 id="학습가이드-06-혼자서-매일-할-수-있는-개인연습"><a href="#학습가이드-06-혼자서-매일-할-수-있는-개인연습" class="headerlink" title="학습가이드 #06 - 혼자서 매일 할 수 있는 개인연습"></a>학습가이드 #06 - 혼자서 매일 할 수 있는 개인연습</h2><ul><li>많은 한국인의 경우, Reading, Writing은 비교적 익숙하나 Speaking이 상대적으로 부족함.</li><li>오늘 하루, 가장 인상 깊었던 대화 내용 하나를 만약 내가 영어로 했다면 어떻게 했을지 생각해보기.</li><li>내가 오늘 말한 표현이 정확한 표현인지 아닌지 알려고 너무 집착하지 말자.</li></ul>]]></content>
      
      
      <categories>
          
          <category> youtube-review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 영어 </tag>
            
            <tag> 빨간모자 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>번역 파이썬 공식문서 __future__</title>
      <link href="/python/What-is-__future__-in-python/"/>
      <url>/python/What-is-__future__-in-python/</url>
      
        <content type="html"><![CDATA[<p>참고문서</p><ul><li><a href="https://docs.python.org/3.8/library/__future__.html" target="_blank" rel="noopener">__future__ — Future statement definitions</a></li></ul><hr><h2 id="future-는-다음-세-가지-용도로-사용됩니다"><a href="#future-는-다음-세-가지-용도로-사용됩니다" class="headerlink" title="__future__는 다음 세 가지 용도로 사용됩니다."></a>__future__는 다음 세 가지 용도로 사용됩니다.</h2><ul><li><p>To avoid confusing existing tools that analyze import statements and expect to find the modules they’re importing.</p></li><li><p>To ensure that future statements run under releases prior to 2.1 at least yield runtime exceptions<br>(the import of <strong>future</strong> will fail, because there was no module of that name prior to 2.1).</p></li><li><p>To document when incompatible changes were introduced, and when they will be — or were — made mandatory.<br>This is a form of executable documentation, and can be inspected programmatically via importing <strong>future</strong> and examining its contents.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> magic method </tag>
            
            <tag> 번역 </tag>
            
            <tag> translation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>일본여행_08</title>
      <link href="/japan/08-tokyo-station/"/>
      <url>/japan/08-tokyo-station/</url>
      
        <content type="html"><![CDATA[<p>8일차</p><p>여행의 마지막 날. 비행시간을 착각했다. 오후 2시 30분으로 알고 있던 비행기 시간이 알고보니 11시 50분이었다. 다행히 9시 10분쯤 그 사실을 깨닫고, 서둘러 집을 나왔다. 서둘렀던 탓인지 여자친구 집에 넥타이를&nbsp;두고 왔다.&nbsp;</p><p>일단 시간을 좀 계산해보면, 산겐자야부터 도쿄역까지 1시간 도쿄역부터 나리타공항까지 1시간이 걸린다. 공항에 도착해 항공권 발급 받고, 출국하는데 1시간을 잡았더니 시간이 매우 모자랐다. 계산하고 앉아 있을 시간도 아까웠지만 전날 밤 미리 준비해두지 않은 탓에 노트북을 꺼내 도쿄역에서 나리타로 가는 버스 타는 법을 검색했다. 역시나 못찾고, 일단 도쿄역으로 향했다. 도쿄역에 도착하니 9시50분이 조금 넘었던가 이미 반쯤은 비행기 타기를 포기했다. 밑져야 본전이라는 마음으로 공항은 가보자는 생각을 했고, 지나가는 경찰을 붙잡고, 나리타 공항 가는 버스 어디서 타냐고 물어봤다.&nbsp;</p><p>나리타 바스와 도코데스까? - 나리타 버스는 어디입니까?&nbsp;</p><p>많이 들어본 질문인지 익숙한 손놀림으로 정류장을 가리켰고, 나는 달리기 시작했다. 옷 밖에 안들어있던&nbsp;가방은&nbsp;왜그리 무거운지.. 힘들었다. 경찰관이 가리킨 곳을 가보니 고속버스 승차장이 아니라 티켓 구매하는 곳 이었다. 예약 안해도 탈 수 있다고 알고 있어서 예약을 안했는데, 그 곳은 예약한 사람들 표 받아가는 곳 인것 같았다. 말이 안통해 지금도 뭔지는 잘 모르겠고, 그곳 안내직원이 영어로 나가서 왼쪽으로 가라고 알려줬고, 그 방향으로 가보니 버스 타려고 기다리는 줄이 한참 길었다.&nbsp;</p><p>이미 시간은 10시가 넘어가기 시작했고, 비행기 놓치는 상상이 머릿속에서 시작됐다.&nbsp;</p><p>일단 버스정류장은 무사히 도착했고, 안내원에게 물어보니 저기 뒤에가서 줄 서라고 말하길래 뒤로 갔는데, 줄이 세줄이었다. 그 중 하나를 골랐는데, 재수없게도 그 줄은 예약한자&nbsp;줄이었고, 내 차례가 되자 난 다시 미예약자 줄 맨 뒤로 가게 됐다. 그곳 시스템은 다음과 같다. 약 10~15분마다 버스가 오는데, 일단 예약자 먼저 꽉 채우고, 남는 자리를 미예약자가 줄 선 순서대로 채우고, 만석이 되면 출발하기를 반복한다.</p><p>다행히 줄이 팍팍 줄어들기 시작했고, 한 걸음 한 걸음 앞으로&nbsp;순조롭게 흘러가는듯 했으나 진짜 딱 내 앞에서 줄이 끝났다. 시트콤 같은 일이 벌어지는구나 싶었는데, 내 앞 선 서양인이 자기는 2인이라고, 지금 한자리면 못탄다 뭐 이런 대화를 나누고 있었다. 근데 생각해보면 내가 한참 전에 왔었는데, 줄을 잘못서서 이런 일이 벌어졌구나 싶기도 한데 겨우 타긴 했으니 기분은 좋았다. 근데 기분이 좋은것도 잠시 버스에 탔는데 안내원이 사람 수를 잘 못 센건지 앉을 자리가 없었다.&nbsp;</p><p>기사가 나보고 앞으로 나오라고 손짓하는데, 난 서서 갈 수 있다. 한국 버스 유 경험자다. 라고 말하고 싶지만 말이 안통하니 어쩔 수 있나… 체념하고, 앞으로 나갔더니 복도에 간이의자가 펴지더니 미안하지만 거기 앉으라고 해서 기분좋게 앉아갔다.(버스요금은 미예약시 1000엔, 예약시 900엔)</p><p>근데 한 가지 문제가 더 있었다. 내가 탈 비행기가 나리타 1,2,3 공항 중 어디서 이륙하는지 모르겠다는 점이 큰 문제였다. 운좋게 좌석과 좌석사이 중앙에 앉은 탓에 양옆으로 사람이 두 명씩 총 네 명이 있었다. 어떻게 일본인에게 스마트폰을 빌려 검색을 할 것인지 고민했고, 구몬 일어로 다져진 나의 일어 실력을 유감없이 발휘할 때라고 생각했다.</p><p>나리타까지 한 시간이 걸리니, 2~3문장 생각하기엔 충분한 시간이었다. 머리속으로 수십번 시뮬레이션을 했지만, ‘나는 외국인입니다’만 수없이 반복될뿐 전화를 빌릴 수는 없었다. 고민하던 찰나 뒤에서 한국인 목소리가 들려왔다. 눈은 앞을 보고 있었지만 이미 내 귀는 그들과 함께였다. 용기를 내서 어디 항공사 타고 가시냐고, 빠르게 물었다. 이스타항공을 기대했지만 아시아나가 나왔고, 1번 공항으로 간다고 했다. 나도 그냥 1번 갈까 고민했지만, 시간이 너무 촉박해서 한 번 잘못내리면 터미널의 톰행크스 부럽지 않은 공항 생활이 나를 기다리고 있겠다싶어 다시 일본어 연습을 시작했다.</p><p>버스 안내방송이 시작됐다. 곧 나리타에 도착한다는 말을 들으니 가슴은 답답해지기 시작했다. 스미마셍으로 포문을 열었다.</p><p>“와따시와 가이코쿠진다카라 와타시노 뎅와가 데키마센” - 나는 외국인이라서 전화가 불가능합니다.</p><p>“아나타노 뎅와오 “ - 당신의 전화를&nbsp;</p><p>여기서 막혔다. 구몬 일어 2년의 결과다. 재능이었다면 달랐을까…&nbsp;</p><p>내 옆에 있던 여자의 당황한 눈을 봤다면, 누구라도 일본어 공부가 하고 싶어졌을텐데 하고 생각하는 순간</p><p>“한국인이세요?” 라고 말하는 당황한 눈의 소유자!</p><p>아 제가 이스타항공 타는데, 어느 공항에 내려야할지 몰라서 검색좀 할 수 있을까요? 하니까 기사님한테 대신 물어봐줬다. 근데 기사님도 모르고해서 narita airport eastarjet으로 검색하니 나왔다. 역시 구글신</p><p>2번 공항이 정답이었고, 11시 10분쯤 버스에 내려 공항에 도착했고, 티켓팅 하는데는 사람이 한 명도 없었다. 늦게갔으니 당연한 듯 했고, 출국 심사 역시 얼마 걸리지 않아 비행기를 무사히 타고 한국에 올 수 있었다.&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> japan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 나리타 </tag>
            
            <tag> 도쿄역 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>일본여행_07</title>
      <link href="/japan/07-sushi/"/>
      <url>/japan/07-sushi/</url>
      
        <content type="html"><![CDATA[<p>7일차</p><p>이제 여행도 하루 남았다.</p><p>일본에 왔으니 스시를 먹어야지…하는 생각으로 오늘 점심은 스시. 사실 록뽄기가서 먹기로 했는데, 사정이 생겨 산겐자야에서 해결하기로 계획을 변경했다.</p><p>검색 결과 역 주변에 있는 작은 지역 스시집으로 들어갔다. 점심 메뉴 2인을 주문하고, 병맥주도 시켰다. 주문을 마치고, 주위를 둘러보니 담배도 피고, 술도 마시고 있는 사람들이 많았다. 그 중 한 명은 일본 개그맨이었는데, 나는 누군지 모르겠고, 내 여자친구가 한국 양배추급 개그맨이다 라고 말했다.(아무런 감흥이 없었다.)</p><p>스시를 먹고 나와 스타벅스에 가서 업무를 좀 보고, 집에 갔다가 꽃 병을 사러 100엔 샵으로 향했다.</p><p>꽃 병 사러 갔다가 형 생일 선물이랑 친구&nbsp;선물도 같이 샀다.&nbsp;</p><p>선물도 다 사고, 집에 오는 길에 스트리트 패션 브랜드 옷가게를 들렸는데, 가격이 참 비싸더라 일본은 옷 가격이 좀 비싼 듯 했다.</p><p>(여행에 관한 기억은 희미해지고 글은&nbsp;점점 짧아진다.)</p>]]></content>
      
      
      <categories>
          
          <category> japan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 스시 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>일본여행_06</title>
      <link href="/japan/06-unagidon/"/>
      <url>/japan/06-unagidon/</url>
      
        <content type="html"><![CDATA[<p>6일차</p><p>사실 지난 토요일에 오늘 먹을 점심 메뉴를 골라뒀었다. 산겐자야역 앞에 있는 상가 입구쪽에 조그마한 크기로 자리 잡고 있는 장어덮밥 집.</p><p>주인에게 이것 저것 물어본 결과, 이 가게는 점심 장사만 한다. 손님이 주문하면 만든다.(20~30분 기다려야 함).&nbsp;</p><p>메뉴는 장어덮밥 뿐, 크기는 일반(1700엔), 대(2500엔), 특대(3500엔)&nbsp;세 종류가 있다.&nbsp;&nbsp;</p><p>일단 자리에 앉아 일반 크기 장어 덮밥을 주문했다. 유창한 일본어로 먼저 선제공격을 날렸다.&nbsp;</p><p>“외국인이라 일본어를 못합니다.”</p><p>일동 침묵…(주인장男, 주인장女, 나)</p><p>20~30분을 기다려야 한다는데, 멍하니 있기 민망해 가방에서 노트를 꺼내 아무거나 끄적거리기 시작했다. 히라가나 쓰는 연습을 하는데, 주인 아주머니가&nbsp;갑자기 말을 걸었다.</p><p>처음에 뭐라고 하는지 못알아들었는데, 두 세번 더 들어보니 어느나라 사람이냐고 묻는것 같아 “칸코쿠진”이라 대답했다. 이제부터 만 3세 일본어로 대화가 시작된다..</p><p>무슨 음식 먹었는지? 낫또 먹어봤는지? 한국 사람도 와사비를 먹는지? 질문 공세에 가까스로 대답을 다 하고, 산겐자야에 볼 만한곳이 뭐가 있는지 물어보니 상당히 난감해 하는 두 사람의 모습을 볼 수 있었다. 대답은 그런거 없다..는 아쉬운 대답을 얻어냈다. 하긴 내가 봐도 볼 건 딱히 없다고 생각했기에 &nbsp;곤란한 질문을 던진 것&nbsp;만으로도&nbsp;만족을 한다.</p><p>이야기를 나누다 보니 시간이 훌쩍 지났고, 먹음직스러운 장어 덮밥이 눈 앞에 있었다. 소라가 들어간 국과 일본식 야채 절임도 함께 나왔다. 하얀 쌀밥 위에 장어가 올라가 있었고, 그 위로 간장 소스가 뿌려졌다.&nbsp;</p><p>상당히 부드러운 식감이 인상적으로 한 입 한 입 입에 넣을때마다&nbsp;입 안 가득 퍼져나가는 장어의 향연….(쓰면서도 민망하다). 적당한 양의 소스가&nbsp;쌀알 사이사이로 스며들었고, 뼈와 잔가시가 모두 제거된 장어는 연두부 마냥 부서지고 있었다.</p><p>이 집의 장어덮밥은 상당히 맛이 좋았다(여기서밖에 안먹어봄). 일본에서 먹은 것 중 가장 맛있었다.&nbsp;</p><p>커피숍 가서 작업 좀 하다가</p><p>록뽄기에 여자친구 회사가 있어서 그 곳으로 향했다.</p><p>록뽄기하면 일본에서 가장 고급스러운 동네라고 해야할까? 아무튼&nbsp;잘 사는 동네다. 애플, 구글 등 글로벌 회사도 많고, 잘 모르겠다. 처음 가봤고, 혼자 돌아보느라 제대로 느껴보진 못했고, 록뽄기 역에서 나와 조금만 걸으면&nbsp;도쿄타워가 눈 앞에 보인다.(꽤 가까운 거리)</p><p>저녁을 먹으려 하는데,&nbsp;오히려 록뽄기 같은 곳에 가면 메뉴선정이 정말 어렵다. 프렌차이즈 식당이&nbsp;많고, 사람도 많고, 정감 가는 식당은 적다. 진심으로 1시간 정도 음식점만 찾아 헤맸다. 중간에 비가와서 그냥 모스버거 들어가서 먹으려다가 록뽄기까지 와서 모스버거 먹는건 마치 지난 겨울 내가 경주에 여행 가서 놀부부대찌개 먹는&nbsp;격 같아 참았다.&nbsp;</p><p>결국 라멘을 먹었는데, 츠케멘을 먹었는데, 한국에서 먹는 것 보다 짰다. 고기는 더 두꺼웠고, 간장 소스에 죽순이 들어있던게 달랐던 점. 고기인줄 알고 씹었는데, 낚일 때 마다 내면의 분노가… 면을 소 중 대로 분류해 팔던데, 내가 시킨건 중이었고, 양은 많았다. 소화가 안되서 고생했다.</p><p>집에 돌아왔다. 록뽄기 같은 곳 한 번 갔다오면 몸이 피곤하다.(한 번 밖에 안가봄)</p>]]></content>
      
      
      <categories>
          
          <category> japan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 우나기동 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>일본여행_05</title>
      <link href="/japan/05-shibuya-shinjuku-shinookubo/"/>
      <url>/japan/05-shibuya-shinjuku-shinookubo/</url>
      
        <content type="html"><![CDATA[<p>5일차 15일 일요일</p><p>아점으로 쇼가야키를 먹었다. 쇼가야키는 생강에 재운 돼지고기를 야채(양배추, 숙주 등)와 함께 볶은 것으로 한국의 제육볶음과 비슷한 느낌이었다. 맛이야 뭐 고기를 야채와 볶았으니 맛있을 수 밖에… 생강을 특별히 싫어하지 않는다면, 한 번 쯤 즐겨 볼 만하다고 생각한다.(즐길 것도 없다 그냥 먹어보는 것)</p><p>적당히 외출준비를 마치고, 시부야로 향했다.&nbsp;시부야에 나와 주위를 둘러보면 다양한 개성을 가진 일본인의&nbsp;옷차림을 볼 수 있다. 시부야 골목 골목을 구경하다 한국의 연예인을 발견했다. 산이와 버벌진트가 화보촬영을 하고 있었다. 쿨하게 지나가려다 그냥 가긴 아쉬워 주변 상점에 들어가 좀 더 훔쳐보고 다시 나와 갈 길을 갔다.&nbsp;</p><p>다음 행선지는 시부야에서 지하철을 타고 신주쿠로 향했다. 신주쿠는 내 개인적인 느낌으로 부평, 광명 쪽이랑 비슷했다. 일단 큰 쇼핑몰을 중심으로 상점가가 발달한 듯 보였고, 대낮부터 성인업소가 활발히 영업중인 점이 특이했다. 과거 한국인 유학생 살인사건 등이 발생했던 장소로 저녁에는 굳이 가지 않는게 좋을 듯 싶었고, 여자 혼자 가기에는 조금 위험한 장소라는 설명에&nbsp;수긍이 갔다.&nbsp;</p><p>신주쿠에는 무료안내소라는 간판이 정말 많다. 관광객을 위한 장소가 아니니 길 모른다고 들어가지 않기를 바란다. 하지만 이러한 걱정은 기우인게, 간판을 보면 19금스러운 기운이 상당히 느껴진다. 성인을 위한 ‘서비스에 대한 설명’이 무료라는 뜻의 무료 안내소로 받아들이면 좋을 듯.&nbsp;</p><p>일본에는 대형 전자제품 양판점이 참 많다. 빅카메라, 요도바시 등 대형 양판점은 관광객이 많이 가는 곳은 물론 대부분의 상업지구에 매장을 두고 있어, 자주 볼 수 있다. 이 중 하나에 들어가 1층 핸드폰 매장부터 시작해 찬찬히 구경을 했다. 중간에 안마의자에 앉아 쉬기도 하고, 일본이나 우리나라나 쇼핑하는 모습은 비슷하다고 생각함.</p><p>&nbsp;다음 행선지는 신오쿠보, 신오쿠보 역시 신주쿠에서 충분히 걸어갈 수 있는 거리이다. (거리상&nbsp;신촌 홍대 느낌)</p><p>신오쿠보는 한인타운이 자리잡고 있는 동네로 과거 상당히 낙후된 지역이었지만, 한류 열풍으로 인해 관광객이 증가했고, 이로인한 지역 상권 활성화로 역 주변 정비라든가 상점의 외관등이 과거보다 많이 나아졌다고 한다. 그래도 신주쿠, 시부야, 록뽄기 등 도쿄 내 주요 도시만 못하다.&nbsp;</p><p>뱅뱅뱅~ 한인타운 골목에 들어서자 빅뱅의 익숙한 멜로디가 들려왔다. 빵야 빵야 빵야</p><p>골목에는 주로 한국 음식점이 많고, 한류 관련 상품 판매점, 네일 샵 등이 있던 것으로 기억난다. 이곳의 음식점에서는 삼겹살, 떡볶이, 김밥을 셋트로 파는 등 한국에서는 절대 볼 수 없는 조합이 난무하고 있다. 게다가 가격마저 비싸니 김밥천국이 그리워지더라. 먹자골목을 주욱 가로질러 나오니 신오쿠보 역이 보였고, 역 바로 옆에는 빠칭코가 있었다.&nbsp;</p><p>빠칭코에 들어갔다. 들어가자마자 기계에서 나오는 굉음에 여자친구의 목소리를 전혀 들을 수 없었고, 담배연기는 2000년대 초반 피시방을 연상케했다. 그리고 둘 다 빠칭코를 한 번도 안해봐서 어떻게 하는지 알 수가 없었다. 점원에게 물어봤지만 상당히 불친절한 태도로 외국인용 안내지를 주고, 자기 자리로 돌아갔다. 결국 한 게임도 못해보고 밖으로 나왔다. 이내 호흡기에선&nbsp;신선한 공기를&nbsp;느낄 수 있었고, 청각기관에선 지하철의 소음마저 잔잔하게 느껴졌다. 고막이 손상된 탓일까? 파칭코 기계의 소음이 엄청났던 탓일까 아직도 궁금하다.</p><p>다시 신주쿠로 걸어갔다. 약 10분정도 걸렸던 것으로 기억나고, 텐동을 먹었다. 텐뿌라 덮밥 == 튀김 덮밥, 밥 위에 양파, 새우, 생선, 피망 튀김이 올라오고 그 위에 간장 소스를 뿌려 먹는다. 전혀 어울리지 않는 조합같지만 먹어보면 느끼하다?! 자주 먹기는 힘들 것 같고, 3년에 2회 정도가 적합해 보인다. 올해 한번 먹었으니 2017년정도에 다시 먹어보는 것으로 이야기를 마친다.</p><p>아 그리고 도큐핸즈라는 곳도 갔는데 국내에 이런곳 없나요?</p>]]></content>
      
      
      <categories>
          
          <category> japan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 시부야 </tag>
            
            <tag> 신주쿠 </tag>
            
            <tag> 신오쿠보 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>일본여행_04</title>
      <link href="/japan/04-sangenjaya/"/>
      <url>/japan/04-sangenjaya/</url>
      
        <content type="html"><![CDATA[<p>4일차 11/14일 토요일</p><p>하루종일 산겐자야에 머물렀다. 오전 11시가 넘은 시간에 느즈막히 일어나 첫 끼니를 간단히 해결하고,&nbsp; 집에서 하루종일 뒹굴거릴 요량으로 침대에 누웠다.&nbsp;</p><p>비가 내리는 도쿄, 서울과 별 다른 느낌은 없었다. 숙소 내에서 무선 인터넷이 안되기에 간단히 씻고, 노트북을 챙겨 주변 카페로 나섰다. 목적지는 나가기전 모바일로 검색해본 “Jam Cafe”, 무엇보다 리뷰가 재밌어서 그곳을 오늘의 카페로 골랐다. 산겐자야 역에서 3분 정도면 도착할 가까운 거리에 있는 잼 카페. 우리나라 카페와 달리 일본 카페는 식사도 함께 제공하는 곳이 많다고 느껴짐. 잼 카페도 그 중 하나였고, 우리는 커피랑 케이크를 주문했다. 일본 케이크는 우리나라보다 비싼데 작고, 맛있어 보이는데 덜 맛있다.(개인적인 느낌)&nbsp;</p><p>밀렸던 작업을 어느정도 해결하고, 카페를 뒤로하고 장을 보러 나왔다. 오늘도 역시 산겐자야 역에 있는 식료품 가게 ‘TOKYU’에 갔고, 바지락과 생선, 맥주, 롤케익 등을 샀던 것으로 기억난다.(이번 편부터 여행 마치고 한국 돌아와 쓰는거라 기억이 가물치)</p><p>집에 오는길에 모스버거에 들려 카라아게 버거를 하나 구입. 가격은 380엔. 맛은 보통. 밥 먹기 전에 배고파서 햄버거를 하나 먹었다.</p><p>일본의 베이커리 가격은 국내보다 대체적으로 비싸다고 느껴진다. 그나마 대형 마트에서 파는 베이커리 후식이 종류도 다양하고, 가격도 상대적으로 저렴하다. 맥주는 에비스, 아사히 레드아이를 골랐다. 아사히 레드아이는 일본의 카고메라는 토마토 쥬스회사와 아사히의 합작품으로 칵테일 레드아이(맥주 + 토마토 쥬스)의 맛과 비슷했다. 토마토의 적당히 단 맛과 새콤한 맛이 어우러졌고, 탄산의 청량감이 목넘김을 깔끔하게 해주었다.</p><p>저녁 메뉴는 바지락을 곁들인 흰살 생선 찜으로 프랑스, 이태리 쪽에서 일반적으로 먹는 가정식이라 한다. 팬에 기름을 충분히 두르고, 다진 마늘을 기름에 올린다. 그리고 생선을 익히기 시작한다. 이 때 호일을 위로 덮어 생선의 윗 면도 익혀주면 좋다(뚜껑이 없어 호일을 썼나?). 적당히 익기 시작하면 요리용 화이트 와인과 바지락을 넣고 충분히 익혀주면 한 끼 식사로 손색없는 음식이 완성된다.(생각보다 간단)</p><p>저녁을 먹고 난 후 롤케익을 먹었다. 한국에 있을 때보다 훨 ~~~~ 씬 많이 먹는다. 한국에 있을때는 보통 하루 두 끼 정도 먹었는데, 여기선 하루 세 끼 꼬박 챙겨먹고, 매 끼니마다 군것질까지 하고 있다.&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> japan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 산겐자야 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>일본여행_03</title>
      <link href="/japan/03-sangenjaya-shibuya/"/>
      <url>/japan/03-sangenjaya-shibuya/</url>
      
        <content type="html"><![CDATA[<p>3일차</p><p>아침은 간단히 컵라면! 컵누들 카레맛으로 상쾌하게 하루를 시작했다. 2000년대 중반에 많이 먹던 카레 라면 맛보다 진했고, 면을 다 먹고나니 밥을 비벼먹고 싶을 정도였다. 말린 감자 후레이크가 상당히 많아 먹는 내내 면과 곁들일 수 있었다. 한국 컵라면과 달리 일본 컵라면은 스프가 이미 뿌려진채로 판매된다.</p><p>집에서 홈페이지 작업 좀 하다보니 금방 점심때가 됐다. 오늘 점심은 라멘 먹기로 어젯밤에 결정.</p><p>근데 교자(만두)만 먹었다. 당연히 라멘집인줄 알고 들어간 음식점이 알고보니 교자 전문점이었다. 이미 자리는 다 잡았기에 나오기는 좀 그래서 만두를 먹었다.&nbsp;</p><p>쿄우노 오스스메와 난데스까 : 오늘의 추천은 무엇입니까?</p><p>라고 했는데 여긴 메뉴가 교자 하나… 구운만두, 물만두만 존재했고, 내가 고르는게 나을 듯 싶어 구운걸로 골랐다. 손가락이 이럴때 유용하다(10개씩이나). 사이드 메뉴는 양배추, 오이, 모르는 음식 3가지가 있었는데 개당 200엔인지 3개 다 합쳐 200엔인지 몰라 그냥 안시켰다. 그랬더니 밥이랑 만두랑 국만 나왔다. 올드보이의 그보다는 3배 정도 나은 상황이지만 당황스럽기론 그와 마찬가지였다. 먹다보니 나름 밥과 만두는 잘 어울린다…가 아니라 그냥 먹었다.&nbsp;</p><p>그런데 일본 식당은 대체로 밥이 맛있다. 쌀이 좋은가 하는 생각을 하다보니 만두는 다 먹었고, 밥은 좀 남았고, 계산하고 나왔다. 밥(소,중,대 사이즈)을 소자로 시킬걸 그랬다. 나름 배 채웠고, 이제 카페를 가야하는데 스타벅스 말고 다른 카페로 향했다.&nbsp;</p><p>커피 한 잔 시켜놓고 4시까지 작업을 계속했다. 실내 금연이 아닌점이 인상 깊었고, 1인당 허용된 자리가 상당히 좁았다. 아이스커피를 주문했다. ‘아이스커피 오네가이시마스(부탁합니다)’라고 말하면 점원은 나의 ‘아이스 커피’를 ‘아이스 코히’로 항상 교정해준다(이런 친절함). 테이크 아웃인지 아닌지 묻고 커피는 동으로 된 잔에 나왔다. 코히는 오래도록 시원했다.</p>]]></content>
      
      
      <categories>
          
          <category> japan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 시부야 </tag>
            
            <tag> 산겐자야 </tag>
            
            <tag> 카페 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>일본여행_02</title>
      <link href="/japan/02-Sangenjaya-Ebisu-Kushiage/"/>
      <url>/japan/02-Sangenjaya-Ebisu-Kushiage/</url>
      
        <content type="html"><![CDATA[<p>2일차</p><p>아침에 일어나 간단하게 컵라면으로 하루를 시작했다.&nbsp;</p><p>오늘은 처음에 왔던 길이 아닌 골목길을 통해 역으로 돌아가기로 마음먹었다. 많은 것들이 눈에 띄었다.</p><p>짱구에서 많이 보던 유치원복을 입은 아이를 태운채 달리는 자전거, 마을을 가로지르는 기찻길(열차 전체 길이가 2량),&nbsp;</p><p>여행 속 작은 여행을 끝 마치고 스타벅스에 들어왔다. 라벤더 티를 한 잔 주문해 2층으로 올라갔다. 아침(10시)에도 몇 자리를 빼곤 사람이 모두 앉아있었다. 노트북 사용자의 대부분은 맥북을 쓰는듯 했고, 서양인도 꽤 있었다.</p><p>오전에 할 작업을 간단히 마치고, 점심을 먹기 위해 밖으로 향했다. 항상 어떤 집을 들어가야할지 상당히 고민한다. 나의 식당 선택 기준은 다음과 같다.</p><ul><li><p>프렌차이즈가 아닌가?&nbsp;</p></li><li><p>1000엔 내외인가?(밥 값이 기본적으로 한국보다 높다.. 천국 천국에 가고싶다.)</p></li><li><p>메뉴판에 그림이 있는가?</p></li><li><p>현재 가게에 사람이 많이 있는가?</p></li></ul><p>이러한 질문에 모두 ‘예’라고 할 수 있는 집을 고르는 편.&nbsp;</p><p>오늘 들어간 집은 일본식 서양 음식점이라고 해야할까? 내가 시킨 메뉴는 정식A (메뉴로 시키는건 어려워 보통 정식A,B,C 중에 고르곤 한다)로 돼지고기 폭챱, 크림치즈를 얹은 명태살, 샐러드, 밥으로 구성된다.</p><p>오늘의 일본어 : 와타시와 칸코쿠진다카라 니혼고가 데키나이데스 (나는 한국인이라 일본어가 불가능합니다.)</p><p>어제 하루 종일 이 말을 연습했고, 익숙해져서 유창하게 내뱉을 수 있었다. 그래서 이 식당 직원인 할머니에게 저 말을 했더니 일본어로 엄청 말을 걸어오기 시작했다. 앞으로 저 말을 할 땐 약간의 연기력이 필요하다고 생각했다. 그리고 할머니가 막 말을 하다가 밥 먹고 음료는 커피, 티 중에 뭘로 할 건지 물었다. 사실 안먹고 싶었는데 안먹겠다는 말을 어찌해야할지 몰라 고민하다가 ‘티’라고 외쳤다. 100엔이 추가되는 순간이었다.</p><p>1000엔을 지불하고 밖으로 나왔다. (잔돈이 안생겨서 좋아..?) &nbsp;</p><p>밥 먹고 산책도 할 겸 마을을 돌아다니다 신사를 발견했다. 들어가려다 무슨 신사인지 모르겠어서 입구에서 발을 돌렸다.</p><p>계속 이어진 강제 산책! 걷다보니 지금 어딘지 가늠이 안가는 수준까지 가버렸다. 슬슬 가방 무게에 어깨가 아파오고, 와이파이 사용가능한 편의점이 보였으면 하는 마음으로 계속 걸었다. 그러던 중 길을 잃었다 싶었는데 교차로를 딱 돌았더니 숙소앞이어서 집에가서 푹 쉬었다.</p><p>집에서 좀 쉬다가 지하철을 타고 산겐자야에서 시부야(2정거장)까지 갔고, 시부야에서부터 에비스(1정거장)까지는 걸어서 갔다. 일본 신 중 한 신의 이름이 에비스이고, 에비스 맥주 역시 유명하다. 에비스 역은 에비스 맥주에서 따왔다고 한다.&nbsp;</p><p>에비스에 도착해서 와이파이가 가능한 까페를 찾기위해 30분 정도 역 주변을 둘러봤다. 입구에 와이파이 가능하다는 그림이 붙여진 까페를 겨우 찾아 일단 주문을 했다. 롤케익과 커피 한 잔, 롤케익은 정말 작았고, 커피는 그냥 커피 맛 이었다. 롤케익으로 허기를 채우고 점원에게 와이파이 비밀번호(와이파이노 파스우-도가 난데스까)를 물었다. 그 말을 하자 점원이 뭔가 곤란한 표정을 지으며 일본어를 속사포로 내뱉었다.(뭔가 안된다는 말 같았는데, 되게 길게 말했다)</p><p>그 후 에비스의 명소 ‘에비스 가든 플레이스’ 갔다가 꼬치요리 집에 들어갔다. 일단 음료를 주문했다. 에비스 맥주가 맛있다는 인터넷 평에 에비스를 시키려고 했으나, 아사히밖에 없어서 엑스트라 콜드 아사히(특별히 더 차가웠는지는 의문)를 시켰다.&nbsp;</p><p>처음으로 맛 본 꼬치는 몽글몽글하게 생긴 겉 모습을 하고 있는 닭 간(liver)으로 맛은 순대 먹을 때 나오는 소 간을 연상하면 비슷하다. 그런데 소 간에 비해 상당히 부드러워 씹을때면 입 안에 닭의 간이 가득 차버린다. 단단한 정도는 연두부, 묵 보다는 단단하고, 삶은 계란 보다 무르다(최근 편의점에서 판매되는 감동란 정도).&nbsp;</p><p>이어 갈아버린 닭고기로 뭉친 꼬치, 닭 날개, 각종 닭 부위(어딘지 모르겠음) 등을 먹었다. 맛과 식감 등 전체적으로 무난했다.&nbsp;</p><p>다음으로 나온 메뉴는 계란말이와 닭 육회.</p><p>계란말이는 한국식 계란말이와 달리 상당히 부풀어올라 부드러운 식감을 자랑하며, 속은 간장의 짠맛이 나면서 표면에선 단맛이 은근히 느껴져 식욕을 자극했다.(이때부터 슬슬 배가 불러오기 시작함)</p><p>닭 육회는 한국에서 먹어본 적이 없었는데 여기 와서 처음 먹게됐다. 우리나라 소고기 육회처럼 길쭉하게 썰려 나오지 않고, 접시 중앙에 계란 노른자를 더한 채로 좀 더 작게 썰려 나왔다. 이미 좀 배가 부른채로 먹어서 그런지 손이 선뜻 가지 않았고, 노른자에 버무려진 채로 먹다보니 목 넘김 시 끈적한 느낌이 들어 내게는 맞지 않았다. (옆자리 손님은 잘먹더라, 소주와 함께였다면 달랐겠지) 반 정도는 남긴채로 나오게 됐고, 다시는 안시킬 것 같은 맛?으로 기억될 듯 하다.</p><p>1인당 3000엔 가량 나옴</p><p>지하철 타고 집 감</p>]]></content>
      
      
      <categories>
          
          <category> japan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 산겐자야 </tag>
            
            <tag> 에비스 </tag>
            
            <tag> 꼬치구이 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>일본여행_01</title>
      <link href="/japan/01-Narita-TokyoStation-Sibuya/"/>
      <url>/japan/01-Narita-TokyoStation-Sibuya/</url>
      
        <content type="html"><![CDATA[<p>1일차</p><p>이른 아침부터 공항에 가려고 준비를 했더니 비행기에 타자마자 눈꺼풀이 내려오기 시작했다. 비행시간은 약 2시간 정도로 부담없었고, 평소 일어나던 9시가 조금 지난 시간에 일본에 도착했다. 공항의 풍경은 대부분의 나라가 그렇듯 여러나라의 비행기와 많은 사람으로 북적이고 있었다.</p><p>간단한 입국심사(사실 아무것도 물어보지 않았다)를 마치고 나와 도쿄로 향하는 버스표를 구입했다. 다양한 교통 수단이 있었지만, 그 중 버스가 1,000엔으로 가장 저렴하기에 고민할 이유가 없었다. (가장 비싼걸로는 3,500엔 고속열차가 있다)</p><p>버스는 10~15분 간격으로 출발했고, 나는 10시 45분 차를 타고 도쿄에 11시 50분 경에 도착했다. 일본 대중교통에 대한 이야기는 많이 들어봐서 알겠지만, 한국과 특히 다른 점은 굉장히 안정적으로 운전한다는 점이 인상깊었다. 하지만 기사 아저씨가 알아듣기 힘들 정도의 작은 목소리로 무언가 주저리 주저리 말하는 점은 우리나라와 비슷했다.</p><p>도쿄역에 도착해 주변 거리를 걷다 스타벅스에 들어가 적당한 음료 하나를 시켜두고, 2시까지 마감인 자소서 하나를 급하게 제출했다. 사실 먹고 싶은 음료가 있었는데, 뭐라 말해야할지 몰라 프로모션 중인 음료 그림을 손짓으로 가리켜 겨우 주문했다.</p><p>음료를 마시고, 밥을 먹으러 밖으로 향했다. 와본적도 없고, 알아보지도 않은 터라 돌아다니다 맛있어 보이는 곳으로 들어갈 생각으로 이쪽 저쪽 둘러보기 시작했고, 몇 분 지나지 않아 사람들이 줄 서 있는 식당을 발견했다. 도쿄역 주변 높게 솟은 세련된 건물에 비해 2층 높이로 아담했고, 나무 느낌을 한 껏 살린 인테리어로 전형적인 일본 식당을 연상케 하는 그런 집이었다.&nbsp;</p><p>십수명의 길었던 줄은 생각보다 빨리 줄어들었고, 어느새 내 차례가 다가왔다. 안내에 따라 들어가보니 직원이 내게 뭐라고 말했고, 뭔말인지 모르고 고개를 끄덕여보니 모르는 사람과 마주보고 앉게 됐다. (아마도 모르는 사람이랑 같이 앉아도 괜찮냐고 물어본 듯 했다.?) 가게 안에는 대략 15명 정도가 밥을 먹고 있었는데, 약속이라도 한 듯 간장을 흠뻑 머금은 두부 반 모 정도가 밥 위에 올라간 정식을 먹고 있었다. 두부 정식으로 유명한 집이구나 생각하면서 한편으로 내가 두부를 싫어한다는 사실도 생각해낸 내 자신이 대견했다.&nbsp;</p><p>역시나 주문이 난관이었다. 그러나 나에겐 손가락이 있기에 메뉴판에 있는 다른 사진을 가리키며 코레 코레(코레는 이것)를 외치니 10분뒤 사진에 있던 음식이 내 앞에 있었다. 닭고기 덮밥을 시켰고, 한국에서 먹던 맛과는 미묘하게 달랐다. 길쭉하게 잘려 올려진 김이 본연의 향을 뽐내는게 상당히 거슬렸고, 알 수 없는 무언가(해초의 일종으로 추정됨)가 간장에 절여진 채로 닭고기 밑에 숨어있었는데 이 놈이 아주 강력했다. 그 알 수 없는 무언가를 먹다보니 두부 먹을걸 그랬나 하는 생각이 들기 시작했다. 알수없는걸 어느정도 걷어내고 김과 닭고기를 곁들여 밥을 먹고 나왔다(800엔).&nbsp;</p><p>밥도 먹었고, 이제 어디를 가야하나 생각하다 아키하바라로 향했다. 내가 아키하바라를 좋아해서 간게 아니라 구글맵을 켜보니 도쿄역에서 아키하바라가 도보로 22분이길래 갔다. 반대방향으로 츠키치 시장이 있었지만 밥을 지금 막 먹었기에 아키하바라로 향했다. 로밍을 안했기에 조금 걷다 세븐일레븐, 패밀리마트, 스타벅스 주변에서 현재 위치를 확인하고, 클리크 수정해 가며 아키하바라로 향했다.&nbsp;</p><p>유일하게 구글맵 없이도 여기가 어딘지 알아볼 수 있을 법한 곳이 아키하바라였다. 어떤 건물이든 예외 없이 애니메이션 캐릭터가 걸려있었고, 거리를 걷다보면 전봇대 간격으로 메이드가 한 명 씩 배치돼 있었다. 아키하바라의 자세한 내용은 생략함.</p><p>아키하바라에서 JR을 타고 시부야로 향했다.(28분, 약 170엔 부가세 미포함) 일본 지하철이 상당히 복잡하다는 평에 조금은 불안했지만 막상 역에 들어가보니 표지판과 안내 문구가 잘 나와있어서 잘못타는 일 없이 시부야로 한 번에 올 수 있었다. 역에서 티켓을 바로 구매할 수도 있지만, 매번 사는건 불편하기에 스이카라는 교통카드를 사서 충전했고, 카드를 이용해서 돌아다녔다. 시부야에서 내려 돌아다니다가 가방이 너무 무거워 어깨도 아프고 피곤해서 다시 지하철을 타고 산겐자야(지명임)로 향했다(4분, 130엔).</p><p>그리고 다시 스타벅스에 들어왔다. 이번엔 프로모션 음료를 안시키겠다는 일념하에 아메리카노를 외쳤고, 지금 마시고 있다. 오늘 하루만 2곳의 스타벅스를 가봤는데, 우리나라랑 비교했을 때 규모가 좀 작다. 사람이 많은 건 한국과 비슷하고(거의 항상 만석), 가격은 조금 더 저렴하다고 느껴짐.</p><p>저녁은 산겐자야 골목을 돌아다니다 발견한 돈까쓰가게에서 해결했다. 히레(안심)까스 정식 (1,250엔)을 주문했다. 이 가게는 할머니와 할아버지 두 분이 운영하시는 듯 해보였다. 왠지 몰라도 그 분들의 나이가 맛을 보장해준다는 느낌을 받았다. 한국과 달리 고기의 형태가 일정하게 잘려있지는 않았다. 오히려 울퉁불퉁한 그 모습이 식욕을 더 자극했다. 곁들여 먹을 양배추와 고기에 소스를 뿌렸고, 고기에는 추가로 레몬(1/4개)즙을 더했다. 이제 먹을 시간이다. 한 입 크게 베었고, 투박한 겉모습과 달리 튀김옷과 고기 모두 부드러웠다. 그리고 약간 느끼하다고 생각될 때 레몬향이 느껴져 질리지 않고 먹을 수 있었다.&nbsp; 사이드 메뉴로는 순두부 1/6모, 된장국 등이 나왔다. 한참 먹다가 PC방의 익숙한 향기가 느껴져 주위를 둘러보니 다른 손님들이 담배로 연기를 만들고 있었다. 일본은 실내 금연이 아니어서 그냥 핀다. 반대로 실내 금연인 경우 입구에 표시를 하곤 한다.</p><p>밥을 다 먹고, 밤과 내일 아침에 먹을 것들을 좀 사러 식료품점에 갔다. TOKYU라는 식료품 점으로 크기는 이마트 에브리데이, 홈플러스 익스프레스 정도로 느껴졌고, 파는 품목도 비슷했다. 맥주 한 캔, 초콜릿, 과자, 귤, 감, 아침에 먹을 컵라면 등을 구입해 집으로 향했다. (마켓오와 서울막걸리(6,000원)를 파는 것을 보고 깜짝 놀람, 가격에 더 놀람)</p>]]></content>
      
      
      <categories>
          
          <category> japan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 나리타 </tag>
            
            <tag> 도쿄역 </tag>
            
            <tag> 시부야 </tag>
            
            <tag> 산겐자야 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
